"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/api/rates/route",{

/***/ "(rsc)/./src/lib/rates/compose.ts":
/*!**********************************!*\
  !*** ./src/lib/rates/compose.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   composeRates: () => (/* binding */ composeRates),\n/* harmony export */   computeCrossRate: () => (/* binding */ computeCrossRate),\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   createRateKey: () => (/* binding */ createRateKey),\n/* harmony export */   getInverseRate: () => (/* binding */ getInverseRate),\n/* harmony export */   roundToSignificantDigits: () => (/* binding */ roundToSignificantDigits)\n/* harmony export */ });\n/* harmony import */ var _providers_bcv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./providers/bcv */ \"(rsc)/./src/lib/rates/providers/bcv.ts\");\n/* harmony import */ var _providers_frankfurter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./providers/frankfurter */ \"(rsc)/./src/lib/rates/providers/frankfurter.ts\");\n/* harmony import */ var _providers_publicFx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./providers/publicFx */ \"(rsc)/./src/lib/rates/providers/publicFx.ts\");\n/* harmony import */ var _providers_alternativeVes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./providers/alternativeVes */ \"(rsc)/./src/lib/rates/providers/alternativeVes.ts\");\n\n\n\n\nfunction createRateKey(base, quote) {\n    return `${base}-${quote}`;\n}\nfunction getInverseRate(rate) {\n    return {\n        base: rate.quote,\n        quote: rate.base,\n        value: 1 / rate.value,\n        provider: rate.provider,\n        at: rate.at\n    };\n}\nfunction roundToSignificantDigits(value, digits = 6) {\n    if (value === 0) return 0;\n    const magnitude = Math.floor(Math.log10(Math.abs(value)));\n    const factor = Math.pow(10, digits - 1 - magnitude);\n    return Math.round(value * factor) / factor;\n}\nfunction computeCrossRate(rate1, rate2, targetBase, targetQuote) {\n    // Check if we can compute the cross rate\n    if (rate1.quote !== rate2.base) {\n        return null;\n    }\n    const crossValue = rate1.value * rate2.value;\n    const roundedValue = roundToSignificantDigits(crossValue);\n    return {\n        base: targetBase,\n        quote: targetQuote,\n        value: roundedValue,\n        provider: `${rate1.provider}+${rate2.provider}`,\n        at: new Date().toISOString()\n    };\n}\nasync function composeRates() {\n    const allRates = {};\n    const providerNotes = [];\n    // Fetch from all providers in parallel\n    const [bcvResult, frankfurterResult, publicFxResult, alternativeVesResult] = await Promise.allSettled([\n        (0,_providers_bcv__WEBPACK_IMPORTED_MODULE_0__.getBCVRates)(),\n        (0,_providers_frankfurter__WEBPACK_IMPORTED_MODULE_1__.getFrankfurterRates)(),\n        (0,_providers_publicFx__WEBPACK_IMPORTED_MODULE_2__.getPublicFxRates)(),\n        (0,_providers_alternativeVes__WEBPACK_IMPORTED_MODULE_3__.getAlternativeVESRates)()\n    ]);\n    // Process BCV results\n    if (bcvResult.status === \"fulfilled\" && bcvResult.value.success) {\n        Object.assign(allRates, bcvResult.value.rates);\n        providerNotes.push(`BCV: ${Object.keys(bcvResult.value.rates).length} rates`);\n    } else {\n        const error = bcvResult.status === \"rejected\" ? bcvResult.reason?.message : bcvResult.value?.error;\n        providerNotes.push(`BCV: Failed (${error})`);\n    }\n    // Process Frankfurter results\n    if (frankfurterResult.status === \"fulfilled\" && frankfurterResult.value.success) {\n        Object.assign(allRates, frankfurterResult.value.rates);\n        providerNotes.push(`Frankfurter: ${Object.keys(frankfurterResult.value.rates).length} rates`);\n    } else {\n        const error = frankfurterResult.status === \"rejected\" ? frankfurterResult.reason?.message : frankfurterResult.value?.error;\n        providerNotes.push(`Frankfurter: Failed (${error})`);\n    }\n    // Process Public FX results\n    if (publicFxResult.status === \"fulfilled\" && publicFxResult.value.success) {\n        Object.assign(allRates, publicFxResult.value.rates);\n        providerNotes.push(`PublicFX: ${Object.keys(publicFxResult.value.rates).length} rates`);\n    } else {\n        const error = publicFxResult.status === \"rejected\" ? publicFxResult.reason?.message : publicFxResult.value?.error;\n        providerNotes.push(`PublicFX: Failed (${error})`);\n    }\n    // Add inverse rates for all direct rates\n    const directRates = {\n        ...allRates\n    };\n    for (const [key, rate] of Object.entries(directRates)){\n        const inverseKey = createRateKey(rate.quote, rate.base);\n        if (!allRates[inverseKey]) {\n            allRates[inverseKey] = getInverseRate(rate);\n        }\n    }\n    // Add fallback rates if we have very few rates\n    if (Object.keys(allRates).length < 4) {\n        providerNotes.push(\"Using fallback rates due to limited data\");\n        // Add some reasonable fallback rates for testing\n        if (!allRates[\"USD-VES\"]) {\n            allRates[\"USD-VES\"] = {\n                base: \"USD\",\n                quote: \"VES\",\n                value: 195.0,\n                provider: \"Fallback\",\n                at: new Date().toISOString()\n            };\n            allRates[\"VES-USD\"] = getInverseRate(allRates[\"USD-VES\"]);\n        }\n        if (!allRates[\"USD-COP\"]) {\n            allRates[\"USD-COP\"] = {\n                base: \"USD\",\n                quote: \"COP\",\n                value: 4100,\n                provider: \"Fallback\",\n                at: new Date().toISOString()\n            };\n            allRates[\"COP-USD\"] = getInverseRate(allRates[\"USD-COP\"]);\n        }\n    }\n    // Compute cross rates for missing pairs\n    const requiredPairs = [\n        \"COP-VES\",\n        \"VES-COP\"\n    ];\n    for (const pair of requiredPairs){\n        if (!allRates[pair]) {\n            const [base, quote] = pair.split(\"-\");\n            // Try COP-VES via COP-USD and USD-VES\n            if (base === \"COP\" && quote === \"VES\") {\n                const copUsd = allRates[\"COP-USD\"];\n                const usdVes = allRates[\"USD-VES\"];\n                if (copUsd && usdVes) {\n                    const crossRate = computeCrossRate(copUsd, usdVes, \"COP\", \"VES\");\n                    if (crossRate) {\n                        allRates[\"COP-VES\"] = crossRate;\n                        allRates[\"VES-COP\"] = getInverseRate(crossRate);\n                        providerNotes.push(\"COP-VES: Computed via COP-USD \\xd7 USD-VES\");\n                    }\n                }\n            }\n        }\n    }\n    return allRates;\n}\nfunction convert(amount, from, to, rates) {\n    if (from === to) return amount;\n    const directKey = createRateKey(from, to);\n    const directRate = rates[directKey];\n    if (directRate) {\n        return roundToSignificantDigits(amount * directRate.value, 8);\n    }\n    // Try cross conversion via USD (most reliable base currency)\n    const fromUsdKey = createRateKey(from, \"USD\");\n    const usdToKey = createRateKey(\"USD\", to);\n    if (rates[fromUsdKey] && rates[usdToKey]) {\n        const viaUsd = amount * rates[fromUsdKey].value * rates[usdToKey].value;\n        return roundToSignificantDigits(viaUsd, 8);\n    }\n    // Try cross conversion via EUR\n    const fromEurKey = createRateKey(from, \"EUR\");\n    const eurToKey = createRateKey(\"EUR\", to);\n    if (rates[fromEurKey] && rates[eurToKey]) {\n        const viaEur = amount * rates[fromEurKey].value * rates[eurToKey].value;\n        return roundToSignificantDigits(viaEur, 8);\n    }\n    // Try cross conversion via COP (for VES-COP specifically)\n    if (from === \"VES\" && to === \"COP\") {\n        const vesUsdKey = createRateKey(\"VES\", \"USD\");\n        const usdCopKey = createRateKey(\"USD\", \"COP\");\n        if (rates[vesUsdKey] && rates[usdCopKey]) {\n            const viaUsd = amount * rates[vesUsdKey].value * rates[usdCopKey].value;\n            return roundToSignificantDigits(viaUsd, 8);\n        }\n    }\n    if (from === \"COP\" && to === \"VES\") {\n        const copUsdKey = createRateKey(\"COP\", \"USD\");\n        const usdVesKey = createRateKey(\"USD\", \"VES\");\n        if (rates[copUsdKey] && rates[usdVesKey]) {\n            const viaUsd = amount * rates[copUsdKey].value * rates[usdVesKey].value;\n            return roundToSignificantDigits(viaUsd, 8);\n        }\n    }\n    // Try multi-hop conversion: VES -> USD -> EUR -> Target\n    if (from === \"VES\" && (to === \"EUR\" || to === \"COP\")) {\n        const vesUsdKey = createRateKey(\"VES\", \"USD\");\n        const usdEurKey = createRateKey(\"USD\", \"EUR\");\n        const eurTargetKey = createRateKey(\"EUR\", to);\n        if (rates[vesUsdKey] && rates[usdEurKey] && rates[eurTargetKey]) {\n            const viaUsdEur = amount * rates[vesUsdKey].value * rates[usdEurKey].value * rates[eurTargetKey].value;\n            return roundToSignificantDigits(viaUsdEur, 8);\n        }\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YXRlcy9jb21wb3NlLnRzPzRjOTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3VycmVuY3ksIFJhdGUsIFJhdGVzQnVuZGxlIH0gZnJvbSAnLi90eXBlcydcclxuaW1wb3J0IHsgZ2V0QkNWUmF0ZXMgfSBmcm9tICcuL3Byb3ZpZGVycy9iY3YnXHJcbmltcG9ydCB7IGdldEZyYW5rZnVydGVyUmF0ZXMgfSBmcm9tICcuL3Byb3ZpZGVycy9mcmFua2Z1cnRlcidcclxuaW1wb3J0IHsgZ2V0UHVibGljRnhSYXRlcyB9IGZyb20gJy4vcHJvdmlkZXJzL3B1YmxpY0Z4J1xyXG5pbXBvcnQgeyBnZXRBbHRlcm5hdGl2ZVZFU1JhdGVzIH0gZnJvbSAnLi9wcm92aWRlcnMvYWx0ZXJuYXRpdmVWZXMnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF0ZUtleShiYXNlOiBDdXJyZW5jeSwgcXVvdGU6IEN1cnJlbmN5KTogc3RyaW5nIHtcclxuICByZXR1cm4gYCR7YmFzZX0tJHtxdW90ZX1gXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnZlcnNlUmF0ZShyYXRlOiBSYXRlKTogUmF0ZSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGJhc2U6IHJhdGUucXVvdGUsXHJcbiAgICBxdW90ZTogcmF0ZS5iYXNlLFxyXG4gICAgdmFsdWU6IDEgLyByYXRlLnZhbHVlLFxyXG4gICAgcHJvdmlkZXI6IHJhdGUucHJvdmlkZXIsXHJcbiAgICBhdDogcmF0ZS5hdFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyh2YWx1ZTogbnVtYmVyLCBkaWdpdHM6IG51bWJlciA9IDYpOiBudW1iZXIge1xyXG4gIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIDBcclxuICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoTWF0aC5hYnModmFsdWUpKSlcclxuICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdygxMCwgZGlnaXRzIC0gMSAtIG1hZ25pdHVkZSlcclxuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGZhY3RvcikgLyBmYWN0b3JcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDcm9zc1JhdGUoXHJcbiAgcmF0ZTE6IFJhdGUsXHJcbiAgcmF0ZTI6IFJhdGUsXHJcbiAgdGFyZ2V0QmFzZTogQ3VycmVuY3ksXHJcbiAgdGFyZ2V0UXVvdGU6IEN1cnJlbmN5XHJcbik6IFJhdGUgfCBudWxsIHtcclxuICAvLyBDaGVjayBpZiB3ZSBjYW4gY29tcHV0ZSB0aGUgY3Jvc3MgcmF0ZVxyXG4gIGlmIChyYXRlMS5xdW90ZSAhPT0gcmF0ZTIuYmFzZSkge1xyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgY3Jvc3NWYWx1ZSA9IHJhdGUxLnZhbHVlICogcmF0ZTIudmFsdWVcclxuICBjb25zdCByb3VuZGVkVmFsdWUgPSByb3VuZFRvU2lnbmlmaWNhbnREaWdpdHMoY3Jvc3NWYWx1ZSlcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgYmFzZTogdGFyZ2V0QmFzZSxcclxuICAgIHF1b3RlOiB0YXJnZXRRdW90ZSxcclxuICAgIHZhbHVlOiByb3VuZGVkVmFsdWUsXHJcbiAgICBwcm92aWRlcjogYCR7cmF0ZTEucHJvdmlkZXJ9KyR7cmF0ZTIucHJvdmlkZXJ9YCxcclxuICAgIGF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21wb3NlUmF0ZXMoKTogUHJvbWlzZTxSYXRlc0J1bmRsZT4ge1xyXG4gIGNvbnN0IGFsbFJhdGVzOiBSYXRlc0J1bmRsZSA9IHt9XHJcbiAgY29uc3QgcHJvdmlkZXJOb3Rlczogc3RyaW5nW10gPSBbXVxyXG4gIFxyXG4gIC8vIEZldGNoIGZyb20gYWxsIHByb3ZpZGVycyBpbiBwYXJhbGxlbFxyXG4gIGNvbnN0IFtiY3ZSZXN1bHQsIGZyYW5rZnVydGVyUmVzdWx0LCBwdWJsaWNGeFJlc3VsdCwgYWx0ZXJuYXRpdmVWZXNSZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtcclxuICAgIGdldEJDVlJhdGVzKCksXHJcbiAgICBnZXRGcmFua2Z1cnRlclJhdGVzKCksXHJcbiAgICBnZXRQdWJsaWNGeFJhdGVzKCksXHJcbiAgICBnZXRBbHRlcm5hdGl2ZVZFU1JhdGVzKClcclxuICBdKVxyXG4gIFxyXG4gIC8vIFByb2Nlc3MgQkNWIHJlc3VsdHNcclxuICBpZiAoYmN2UmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgYmN2UmVzdWx0LnZhbHVlLnN1Y2Nlc3MpIHtcclxuICAgIE9iamVjdC5hc3NpZ24oYWxsUmF0ZXMsIGJjdlJlc3VsdC52YWx1ZS5yYXRlcylcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaChgQkNWOiAke09iamVjdC5rZXlzKGJjdlJlc3VsdC52YWx1ZS5yYXRlcykubGVuZ3RofSByYXRlc2ApXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGVycm9yID0gYmN2UmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJyA/IGJjdlJlc3VsdC5yZWFzb24/Lm1lc3NhZ2UgOiBiY3ZSZXN1bHQudmFsdWU/LmVycm9yXHJcbiAgICBwcm92aWRlck5vdGVzLnB1c2goYEJDVjogRmFpbGVkICgke2Vycm9yfSlgKVxyXG4gIH1cclxuICBcclxuICAvLyBQcm9jZXNzIEZyYW5rZnVydGVyIHJlc3VsdHNcclxuICBpZiAoZnJhbmtmdXJ0ZXJSZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJyAmJiBmcmFua2Z1cnRlclJlc3VsdC52YWx1ZS5zdWNjZXNzKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKGFsbFJhdGVzLCBmcmFua2Z1cnRlclJlc3VsdC52YWx1ZS5yYXRlcylcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaChgRnJhbmtmdXJ0ZXI6ICR7T2JqZWN0LmtleXMoZnJhbmtmdXJ0ZXJSZXN1bHQudmFsdWUucmF0ZXMpLmxlbmd0aH0gcmF0ZXNgKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBlcnJvciA9IGZyYW5rZnVydGVyUmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJyA/IGZyYW5rZnVydGVyUmVzdWx0LnJlYXNvbj8ubWVzc2FnZSA6IGZyYW5rZnVydGVyUmVzdWx0LnZhbHVlPy5lcnJvclxyXG4gICAgcHJvdmlkZXJOb3Rlcy5wdXNoKGBGcmFua2Z1cnRlcjogRmFpbGVkICgke2Vycm9yfSlgKVxyXG4gIH1cclxuICBcclxuICAvLyBQcm9jZXNzIFB1YmxpYyBGWCByZXN1bHRzXHJcbiAgaWYgKHB1YmxpY0Z4UmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgcHVibGljRnhSZXN1bHQudmFsdWUuc3VjY2Vzcykge1xyXG4gICAgT2JqZWN0LmFzc2lnbihhbGxSYXRlcywgcHVibGljRnhSZXN1bHQudmFsdWUucmF0ZXMpXHJcbiAgICBwcm92aWRlck5vdGVzLnB1c2goYFB1YmxpY0ZYOiAke09iamVjdC5rZXlzKHB1YmxpY0Z4UmVzdWx0LnZhbHVlLnJhdGVzKS5sZW5ndGh9IHJhdGVzYClcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgZXJyb3IgPSBwdWJsaWNGeFJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcgPyBwdWJsaWNGeFJlc3VsdC5yZWFzb24/Lm1lc3NhZ2UgOiBwdWJsaWNGeFJlc3VsdC52YWx1ZT8uZXJyb3JcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaChgUHVibGljRlg6IEZhaWxlZCAoJHtlcnJvcn0pYClcclxuICB9XHJcbiAgXHJcbiAgLy8gQWRkIGludmVyc2UgcmF0ZXMgZm9yIGFsbCBkaXJlY3QgcmF0ZXNcclxuICBjb25zdCBkaXJlY3RSYXRlcyA9IHsgLi4uYWxsUmF0ZXMgfVxyXG4gIGZvciAoY29uc3QgW2tleSwgcmF0ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGlyZWN0UmF0ZXMpKSB7XHJcbiAgICBjb25zdCBpbnZlcnNlS2V5ID0gY3JlYXRlUmF0ZUtleShyYXRlLnF1b3RlLCByYXRlLmJhc2UpXHJcbiAgICBpZiAoIWFsbFJhdGVzW2ludmVyc2VLZXldKSB7XHJcbiAgICAgIGFsbFJhdGVzW2ludmVyc2VLZXldID0gZ2V0SW52ZXJzZVJhdGUocmF0ZSlcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gQWRkIGZhbGxiYWNrIHJhdGVzIGlmIHdlIGhhdmUgdmVyeSBmZXcgcmF0ZXNcclxuICBpZiAoT2JqZWN0LmtleXMoYWxsUmF0ZXMpLmxlbmd0aCA8IDQpIHtcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaCgnVXNpbmcgZmFsbGJhY2sgcmF0ZXMgZHVlIHRvIGxpbWl0ZWQgZGF0YScpXHJcbiAgICBcclxuICAgIC8vIEFkZCBzb21lIHJlYXNvbmFibGUgZmFsbGJhY2sgcmF0ZXMgZm9yIHRlc3RpbmdcclxuICAgIGlmICghYWxsUmF0ZXNbJ1VTRC1WRVMnXSkge1xyXG4gICAgICBhbGxSYXRlc1snVVNELVZFUyddID0ge1xyXG4gICAgICAgIGJhc2U6ICdVU0QnLFxyXG4gICAgICAgIHF1b3RlOiAnVkVTJyxcclxuICAgICAgICB2YWx1ZTogMTk1LjAsIC8vIFVwZGF0ZWQgYXBwcm94aW1hdGUgcmF0ZSAoT2N0b2JlciAyMDI0KVxyXG4gICAgICAgIHByb3ZpZGVyOiAnRmFsbGJhY2snLFxyXG4gICAgICAgIGF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfVxyXG4gICAgICBhbGxSYXRlc1snVkVTLVVTRCddID0gZ2V0SW52ZXJzZVJhdGUoYWxsUmF0ZXNbJ1VTRC1WRVMnXSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKCFhbGxSYXRlc1snVVNELUNPUCddKSB7XHJcbiAgICAgIGFsbFJhdGVzWydVU0QtQ09QJ10gPSB7XHJcbiAgICAgICAgYmFzZTogJ1VTRCcsXHJcbiAgICAgICAgcXVvdGU6ICdDT1AnLFxyXG4gICAgICAgIHZhbHVlOiA0MTAwLCAvLyBBcHByb3hpbWF0ZSByYXRlXHJcbiAgICAgICAgcHJvdmlkZXI6ICdGYWxsYmFjaycsXHJcbiAgICAgICAgYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9XHJcbiAgICAgIGFsbFJhdGVzWydDT1AtVVNEJ10gPSBnZXRJbnZlcnNlUmF0ZShhbGxSYXRlc1snVVNELUNPUCddKVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBDb21wdXRlIGNyb3NzIHJhdGVzIGZvciBtaXNzaW5nIHBhaXJzXHJcbiAgY29uc3QgcmVxdWlyZWRQYWlycyA9IFtcclxuICAgICdDT1AtVkVTJywgJ1ZFUy1DT1AnXHJcbiAgXVxyXG4gIFxyXG4gIGZvciAoY29uc3QgcGFpciBvZiByZXF1aXJlZFBhaXJzKSB7XHJcbiAgICBpZiAoIWFsbFJhdGVzW3BhaXJdKSB7XHJcbiAgICAgIGNvbnN0IFtiYXNlLCBxdW90ZV0gPSBwYWlyLnNwbGl0KCctJykgYXMgW0N1cnJlbmN5LCBDdXJyZW5jeV1cclxuICAgICAgXHJcbiAgICAgIC8vIFRyeSBDT1AtVkVTIHZpYSBDT1AtVVNEIGFuZCBVU0QtVkVTXHJcbiAgICAgIGlmIChiYXNlID09PSAnQ09QJyAmJiBxdW90ZSA9PT0gJ1ZFUycpIHtcclxuICAgICAgICBjb25zdCBjb3BVc2QgPSBhbGxSYXRlc1snQ09QLVVTRCddXHJcbiAgICAgICAgY29uc3QgdXNkVmVzID0gYWxsUmF0ZXNbJ1VTRC1WRVMnXVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjb3BVc2QgJiYgdXNkVmVzKSB7XHJcbiAgICAgICAgICBjb25zdCBjcm9zc1JhdGUgPSBjb21wdXRlQ3Jvc3NSYXRlKGNvcFVzZCwgdXNkVmVzLCAnQ09QJywgJ1ZFUycpXHJcbiAgICAgICAgICBpZiAoY3Jvc3NSYXRlKSB7XHJcbiAgICAgICAgICAgIGFsbFJhdGVzWydDT1AtVkVTJ10gPSBjcm9zc1JhdGVcclxuICAgICAgICAgICAgYWxsUmF0ZXNbJ1ZFUy1DT1AnXSA9IGdldEludmVyc2VSYXRlKGNyb3NzUmF0ZSlcclxuICAgICAgICAgICAgcHJvdmlkZXJOb3Rlcy5wdXNoKCdDT1AtVkVTOiBDb21wdXRlZCB2aWEgQ09QLVVTRCDDlyBVU0QtVkVTJylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGFsbFJhdGVzXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0KFxyXG4gIGFtb3VudDogbnVtYmVyLFxyXG4gIGZyb206IEN1cnJlbmN5LFxyXG4gIHRvOiBDdXJyZW5jeSxcclxuICByYXRlczogUmF0ZXNCdW5kbGVcclxuKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gYW1vdW50XHJcbiAgXHJcbiAgY29uc3QgZGlyZWN0S2V5ID0gY3JlYXRlUmF0ZUtleShmcm9tLCB0bylcclxuICBjb25zdCBkaXJlY3RSYXRlID0gcmF0ZXNbZGlyZWN0S2V5XVxyXG4gIFxyXG4gIGlmIChkaXJlY3RSYXRlKSB7XHJcbiAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKGFtb3VudCAqIGRpcmVjdFJhdGUudmFsdWUsIDgpXHJcbiAgfVxyXG4gIFxyXG4gIC8vIFRyeSBjcm9zcyBjb252ZXJzaW9uIHZpYSBVU0QgKG1vc3QgcmVsaWFibGUgYmFzZSBjdXJyZW5jeSlcclxuICBjb25zdCBmcm9tVXNkS2V5ID0gY3JlYXRlUmF0ZUtleShmcm9tLCAnVVNEJylcclxuICBjb25zdCB1c2RUb0tleSA9IGNyZWF0ZVJhdGVLZXkoJ1VTRCcsIHRvKVxyXG4gIFxyXG4gIGlmIChyYXRlc1tmcm9tVXNkS2V5XSAmJiByYXRlc1t1c2RUb0tleV0pIHtcclxuICAgIGNvbnN0IHZpYVVzZCA9IGFtb3VudCAqIHJhdGVzW2Zyb21Vc2RLZXldLnZhbHVlICogcmF0ZXNbdXNkVG9LZXldLnZhbHVlXHJcbiAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZpYVVzZCwgOClcclxuICB9XHJcbiAgXHJcbiAgLy8gVHJ5IGNyb3NzIGNvbnZlcnNpb24gdmlhIEVVUlxyXG4gIGNvbnN0IGZyb21FdXJLZXkgPSBjcmVhdGVSYXRlS2V5KGZyb20sICdFVVInKVxyXG4gIGNvbnN0IGV1clRvS2V5ID0gY3JlYXRlUmF0ZUtleSgnRVVSJywgdG8pXHJcbiAgXHJcbiAgaWYgKHJhdGVzW2Zyb21FdXJLZXldICYmIHJhdGVzW2V1clRvS2V5XSkge1xyXG4gICAgY29uc3QgdmlhRXVyID0gYW1vdW50ICogcmF0ZXNbZnJvbUV1cktleV0udmFsdWUgKiByYXRlc1tldXJUb0tleV0udmFsdWVcclxuICAgIHJldHVybiByb3VuZFRvU2lnbmlmaWNhbnREaWdpdHModmlhRXVyLCA4KVxyXG4gIH1cclxuICBcclxuICAvLyBUcnkgY3Jvc3MgY29udmVyc2lvbiB2aWEgQ09QIChmb3IgVkVTLUNPUCBzcGVjaWZpY2FsbHkpXHJcbiAgaWYgKGZyb20gPT09ICdWRVMnICYmIHRvID09PSAnQ09QJykge1xyXG4gICAgY29uc3QgdmVzVXNkS2V5ID0gY3JlYXRlUmF0ZUtleSgnVkVTJywgJ1VTRCcpXHJcbiAgICBjb25zdCB1c2RDb3BLZXkgPSBjcmVhdGVSYXRlS2V5KCdVU0QnLCAnQ09QJylcclxuICAgIFxyXG4gICAgaWYgKHJhdGVzW3Zlc1VzZEtleV0gJiYgcmF0ZXNbdXNkQ29wS2V5XSkge1xyXG4gICAgICBjb25zdCB2aWFVc2QgPSBhbW91bnQgKiByYXRlc1t2ZXNVc2RLZXldLnZhbHVlICogcmF0ZXNbdXNkQ29wS2V5XS52YWx1ZVxyXG4gICAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZpYVVzZCwgOClcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgaWYgKGZyb20gPT09ICdDT1AnICYmIHRvID09PSAnVkVTJykge1xyXG4gICAgY29uc3QgY29wVXNkS2V5ID0gY3JlYXRlUmF0ZUtleSgnQ09QJywgJ1VTRCcpXHJcbiAgICBjb25zdCB1c2RWZXNLZXkgPSBjcmVhdGVSYXRlS2V5KCdVU0QnLCAnVkVTJylcclxuICAgIFxyXG4gICAgaWYgKHJhdGVzW2NvcFVzZEtleV0gJiYgcmF0ZXNbdXNkVmVzS2V5XSkge1xyXG4gICAgICBjb25zdCB2aWFVc2QgPSBhbW91bnQgKiByYXRlc1tjb3BVc2RLZXldLnZhbHVlICogcmF0ZXNbdXNkVmVzS2V5XS52YWx1ZVxyXG4gICAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZpYVVzZCwgOClcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gVHJ5IG11bHRpLWhvcCBjb252ZXJzaW9uOiBWRVMgLT4gVVNEIC0+IEVVUiAtPiBUYXJnZXRcclxuICBpZiAoZnJvbSA9PT0gJ1ZFUycgJiYgKHRvID09PSAnRVVSJyB8fCB0byA9PT0gJ0NPUCcpKSB7XHJcbiAgICBjb25zdCB2ZXNVc2RLZXkgPSBjcmVhdGVSYXRlS2V5KCdWRVMnLCAnVVNEJylcclxuICAgIGNvbnN0IHVzZEV1cktleSA9IGNyZWF0ZVJhdGVLZXkoJ1VTRCcsICdFVVInKVxyXG4gICAgY29uc3QgZXVyVGFyZ2V0S2V5ID0gY3JlYXRlUmF0ZUtleSgnRVVSJywgdG8pXHJcbiAgICBcclxuICAgIGlmIChyYXRlc1t2ZXNVc2RLZXldICYmIHJhdGVzW3VzZEV1cktleV0gJiYgcmF0ZXNbZXVyVGFyZ2V0S2V5XSkge1xyXG4gICAgICBjb25zdCB2aWFVc2RFdXIgPSBhbW91bnQgKiByYXRlc1t2ZXNVc2RLZXldLnZhbHVlICogcmF0ZXNbdXNkRXVyS2V5XS52YWx1ZSAqIHJhdGVzW2V1clRhcmdldEtleV0udmFsdWVcclxuICAgICAgcmV0dXJuIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyh2aWFVc2RFdXIsIDgpXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBudWxsXHJcbn1cclxuIl0sIm5hbWVzIjpbImdldEJDVlJhdGVzIiwiZ2V0RnJhbmtmdXJ0ZXJSYXRlcyIsImdldFB1YmxpY0Z4UmF0ZXMiLCJnZXRBbHRlcm5hdGl2ZVZFU1JhdGVzIiwiY3JlYXRlUmF0ZUtleSIsImJhc2UiLCJxdW90ZSIsImdldEludmVyc2VSYXRlIiwicmF0ZSIsInZhbHVlIiwicHJvdmlkZXIiLCJhdCIsInJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyIsImRpZ2l0cyIsIm1hZ25pdHVkZSIsIk1hdGgiLCJmbG9vciIsImxvZzEwIiwiYWJzIiwiZmFjdG9yIiwicG93Iiwicm91bmQiLCJjb21wdXRlQ3Jvc3NSYXRlIiwicmF0ZTEiLCJyYXRlMiIsInRhcmdldEJhc2UiLCJ0YXJnZXRRdW90ZSIsImNyb3NzVmFsdWUiLCJyb3VuZGVkVmFsdWUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb21wb3NlUmF0ZXMiLCJhbGxSYXRlcyIsInByb3ZpZGVyTm90ZXMiLCJiY3ZSZXN1bHQiLCJmcmFua2Z1cnRlclJlc3VsdCIsInB1YmxpY0Z4UmVzdWx0IiwiYWx0ZXJuYXRpdmVWZXNSZXN1bHQiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsInN0YXR1cyIsInN1Y2Nlc3MiLCJPYmplY3QiLCJhc3NpZ24iLCJyYXRlcyIsInB1c2giLCJrZXlzIiwibGVuZ3RoIiwiZXJyb3IiLCJyZWFzb24iLCJtZXNzYWdlIiwiZGlyZWN0UmF0ZXMiLCJrZXkiLCJlbnRyaWVzIiwiaW52ZXJzZUtleSIsInJlcXVpcmVkUGFpcnMiLCJwYWlyIiwic3BsaXQiLCJjb3BVc2QiLCJ1c2RWZXMiLCJjcm9zc1JhdGUiLCJjb252ZXJ0IiwiYW1vdW50IiwiZnJvbSIsInRvIiwiZGlyZWN0S2V5IiwiZGlyZWN0UmF0ZSIsImZyb21Vc2RLZXkiLCJ1c2RUb0tleSIsInZpYVVzZCIsImZyb21FdXJLZXkiLCJldXJUb0tleSIsInZpYUV1ciIsInZlc1VzZEtleSIsInVzZENvcEtleSIsImNvcFVzZEtleSIsInVzZFZlc0tleSIsInVzZEV1cktleSIsImV1clRhcmdldEtleSIsInZpYVVzZEV1ciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/rates/compose.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/rates/providers/alternativeVes.ts":
/*!***************************************************!*\
  !*** ./src/lib/rates/providers/alternativeVes.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAlternativeVESRates: () => (/* binding */ getAlternativeVESRates)\n/* harmony export */ });\n// Alternative sources for VES rates that might work better\nconst ALTERNATIVE_VES_SOURCES = [\n    {\n        name: \"XE.com\",\n        url: \"https://www.xe.com/currencyconverter/convert/?Amount=1&From=USD&To=VES\",\n        parseHtml: true\n    },\n    {\n        name: \"Wise.com\",\n        url: \"https://wise.com/us/currency-converter/usd-to-ves-rate\",\n        parseHtml: true\n    },\n    {\n        name: \"CurrencyAPI\",\n        url: \"https://api.currencyapi.com/v3/latest?base_currency=USD&currencies=VES\",\n        parseHtml: false\n    }\n];\nasync function fetchWithRetry(url, options = {}, retries = 2) {\n    for(let i = 0; i < retries; i++){\n        try {\n            const response = await fetch(url, {\n                ...options,\n                headers: {\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n                    \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                    \"Accept-Language\": \"en-US,en;q=0.5\",\n                    \"Accept-Encoding\": \"gzip, deflate, br\",\n                    \"Connection\": \"keep-alive\",\n                    \"Upgrade-Insecure-Requests\": \"1\",\n                    ...options.headers\n                }\n            });\n            if (response.ok) {\n                return response;\n            }\n        } catch (error) {\n            console.warn(`Attempt ${i + 1} failed for ${url}:`, error);\n            if (i === retries - 1) throw error;\n            await new Promise((resolve)=>setTimeout(resolve, 1000 * (i + 1)));\n        }\n    }\n    throw new Error(\"All retry attempts failed\");\n}\nfunction parseVESFromHTML(html, source) {\n    const rates = {};\n    // Multiple patterns to try for USD/VES\n    const usdPatterns = [\n        // XE.com patterns\n        /1\\s*USD\\s*=\\s*([\\d,\\.]+)\\s*VES/i,\n        /USD\\s*to\\s*VES[^>]*>([\\d,\\.]+)</i,\n        // Wise.com patterns\n        /1\\s*US\\s*dollar\\s*=\\s*([\\d,\\.]+)\\s*VES/i,\n        /USD\\s*to\\s*VES[^>]*>([\\d,\\.]+)</i,\n        // Generic patterns\n        /USD\\s*=\\s*([\\d,\\.]+)\\s*VES/i,\n        /1\\s*USD\\s*=\\s*([\\d,\\.]+)\\s*Bolívar/i,\n        /Dólar\\s*=\\s*([\\d,\\.]+)\\s*Bolívar/i\n    ];\n    for (const pattern of usdPatterns){\n        const match = html.match(pattern);\n        if (match) {\n            const rate = parseFloat(match[1].replace(/,/g, \"\"));\n            if (!isNaN(rate) && rate > 50 && rate < 1000) {\n                rates[\"USD-VES\"] = {\n                    base: \"USD\",\n                    quote: \"VES\",\n                    value: rate,\n                    provider: source,\n                    at: new Date().toISOString()\n                };\n                break;\n            }\n        }\n    }\n    return rates;\n}\nfunction parseVESFromJSON(data, source) {\n    const rates = {};\n    try {\n        let usdVesRate = null;\n        if (source === \"CurrencyAPI\") {\n            if (data.data?.VES?.value) {\n                usdVesRate = data.data.VES.value;\n            }\n        }\n        if (usdVesRate && usdVesRate > 50 && usdVesRate < 1000) {\n            rates[\"USD-VES\"] = {\n                base: \"USD\",\n                quote: \"VES\",\n                value: usdVesRate,\n                provider: source,\n                at: data.meta?.last_updated_at || new Date().toISOString()\n            };\n        }\n    } catch (error) {\n        console.warn(`Failed to parse ${source} JSON response:`, error);\n    }\n    return rates;\n}\nasync function getAlternativeVESRates() {\n    const allRates = [];\n    const errors = [];\n    const apiKey = process.env.PUBLIC_FX_API_KEY;\n    // Try multiple sources in parallel\n    const sourcePromises = ALTERNATIVE_VES_SOURCES.map(async (source)=>{\n        // Skip sources that require API key if we don't have one\n        if (source.name === \"CurrencyAPI\" && !apiKey) {\n            return {\n                source: source.name,\n                rates: [],\n                success: false,\n                error: \"API key required but not provided\"\n            };\n        }\n        try {\n            let url = source.url;\n            // Add API key to URL if required\n            if (source.name === \"CurrencyAPI\" && apiKey) {\n                url = `${source.url}&apikey=${apiKey}`;\n            }\n            const response = await fetchWithRetry(url, {\n                next: {\n                    revalidate: 3600\n                }\n            });\n            if (source.parseHtml) {\n                const html = await response.text();\n                const rates = parseVESFromHTML(html, source.name);\n                return {\n                    source: source.name,\n                    rates: Object.values(rates),\n                    success: Object.keys(rates).length > 0\n                };\n            } else {\n                const data = await response.json();\n                const rates = parseVESFromJSON(data, source.name);\n                return {\n                    source: source.name,\n                    rates: Object.values(rates),\n                    success: Object.keys(rates).length > 0\n                };\n            }\n        } catch (error) {\n            console.warn(`${source.name} failed:`, error);\n            return {\n                source: source.name,\n                rates: [],\n                success: false,\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    });\n    const results = await Promise.allSettled(sourcePromises);\n    // Collect all successful rates\n    results.forEach((result)=>{\n        if (result.status === \"fulfilled\" && result.value.success) {\n            allRates.push(...result.value.rates);\n        } else if (result.status === \"rejected\") {\n            errors.push(result.reason?.message || \"Unknown error\");\n        }\n    });\n    if (allRates.length === 0) {\n        return {\n            rates: {},\n            provider: \"Alternative-VES\",\n            success: false,\n            error: `All sources failed: ${errors.join(\", \")}`\n        };\n    }\n    // Average rates from multiple sources\n    const averagedRates = {};\n    const usdVesRates = allRates.filter((r)=>r.base === \"USD\" && r.quote === \"VES\");\n    if (usdVesRates.length > 0) {\n        const avgUsdVes = usdVesRates.reduce((sum, r)=>sum + r.value, 0) / usdVesRates.length;\n        averagedRates[\"USD-VES\"] = {\n            base: \"USD\",\n            quote: \"VES\",\n            value: avgUsdVes,\n            provider: `Average of ${usdVesRates.length} sources`,\n            at: new Date().toISOString()\n        };\n    }\n    return {\n        rates: averagedRates,\n        provider: \"Alternative-VES\",\n        success: true\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL3JhdGVzL3Byb3ZpZGVycy9hbHRlcm5hdGl2ZVZlcy50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsMkRBQTJEO0FBQzNELE1BQU1BLDBCQUEwQjtJQUM5QjtRQUNFQyxNQUFNO1FBQ05DLEtBQUs7UUFDTEMsV0FBVztJQUNiO0lBQ0E7UUFDRUYsTUFBTTtRQUNOQyxLQUFLO1FBQ0xDLFdBQVc7SUFDYjtJQUNBO1FBQ0VGLE1BQU07UUFDTkMsS0FBSztRQUNMQyxXQUFXO0lBQ2I7Q0FDRDtBQUVELGVBQWVDLGVBQWVGLEdBQVcsRUFBRUcsVUFBdUIsQ0FBQyxDQUFDLEVBQUVDLFVBQVUsQ0FBQztJQUMvRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsU0FBU0MsSUFBSztRQUNoQyxJQUFJO1lBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNUCxLQUFLO2dCQUNoQyxHQUFHRyxPQUFPO2dCQUNWSyxTQUFTO29CQUNQLGNBQWM7b0JBQ2QsVUFBVTtvQkFDVixtQkFBbUI7b0JBQ25CLG1CQUFtQjtvQkFDbkIsY0FBYztvQkFDZCw2QkFBNkI7b0JBQzdCLEdBQUdMLFFBQVFLLE9BQU87Z0JBQ3BCO1lBQ0Y7WUFFQSxJQUFJRixTQUFTRyxFQUFFLEVBQUU7Z0JBQ2YsT0FBT0g7WUFDVDtRQUNGLEVBQUUsT0FBT0ksT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUVQLElBQUksRUFBRSxZQUFZLEVBQUVMLElBQUksQ0FBQyxDQUFDLEVBQUVVO1lBQ3BELElBQUlMLE1BQU1ELFVBQVUsR0FBRyxNQUFNTTtZQUM3QixNQUFNLElBQUlHLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVMsT0FBUVQsQ0FBQUEsSUFBSTtRQUMvRDtJQUNGO0lBQ0EsTUFBTSxJQUFJVyxNQUFNO0FBQ2xCO0FBRUEsU0FBU0MsaUJBQWlCQyxJQUFZLEVBQUVDLE1BQWM7SUFDcEQsTUFBTUMsUUFBOEIsQ0FBQztJQUVyQyx1Q0FBdUM7SUFDdkMs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M0MsSUFBSSxLQUFLLFNBQVMyQyxFQUFFMUMsS0FBSyxLQUFLO0lBRXpFLElBQUl3QyxZQUFZWixNQUFNLEdBQUcsR0FBRztRQUMxQixNQUFNZSxZQUFZSCxZQUFZSSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0gsSUFBTUcsTUFBTUgsRUFBRXpDLEtBQUssRUFBRSxLQUFLdUMsWUFBWVosTUFBTTtRQUN2RlcsYUFBYSxDQUFDLFVBQVUsR0FBRztZQUN6QnhDLE1BQU07WUFDTkMsT0FBTztZQUNQQyxPQUFPMEM7WUFDUHpDLFVBQVUsQ0FBQyxXQUFXLEVBQUVzQyxZQUFZWixNQUFNLENBQUMsUUFBUSxDQUFDO1lBQ3BEekIsSUFBSSxJQUFJQyxPQUFPQyxXQUFXO1FBQzVCO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xkLE9BQU9nRDtRQUNQckMsVUFBVTtRQUNWbUIsU0FBUztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9yYXRlcy9wcm92aWRlcnMvYWx0ZXJuYXRpdmVWZXMudHM/ZmQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXRlLCBSYXRlc0J1bmRsZSwgUHJvdmlkZXJSZXN1bHQgfSBmcm9tICcuLi90eXBlcydcclxuXHJcbi8vIEFsdGVybmF0aXZlIHNvdXJjZXMgZm9yIFZFUyByYXRlcyB0aGF0IG1pZ2h0IHdvcmsgYmV0dGVyXHJcbmNvbnN0IEFMVEVSTkFUSVZFX1ZFU19TT1VSQ0VTID0gW1xyXG4gIHtcclxuICAgIG5hbWU6ICdYRS5jb20nLFxyXG4gICAgdXJsOiAnaHR0cHM6Ly93d3cueGUuY29tL2N1cnJlbmN5Y29udmVydGVyL2NvbnZlcnQvP0Ftb3VudD0xJkZyb209VVNEJlRvPVZFUycsXHJcbiAgICBwYXJzZUh0bWw6IHRydWVcclxuICB9LFxyXG4gIHtcclxuICAgIG5hbWU6ICdXaXNlLmNvbScsXHJcbiAgICB1cmw6ICdodHRwczovL3dpc2UuY29tL3VzL2N1cnJlbmN5LWNvbnZlcnRlci91c2QtdG8tdmVzLXJhdGUnLFxyXG4gICAgcGFyc2VIdG1sOiB0cnVlXHJcbiAgfSxcclxuICB7XHJcbiAgICBuYW1lOiAnQ3VycmVuY3lBUEknLFxyXG4gICAgdXJsOiAnaHR0cHM6Ly9hcGkuY3VycmVuY3lhcGkuY29tL3YzL2xhdGVzdD9iYXNlX2N1cnJlbmN5PVVTRCZjdXJyZW5jaWVzPVZFUycsXHJcbiAgICBwYXJzZUh0bWw6IGZhbHNlXHJcbiAgfVxyXG5dXHJcblxyXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhSZXRyeSh1cmw6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fSwgcmV0cmllcyA9IDIpOiBQcm9taXNlPFJlc3BvbnNlPiB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyaWVzOyBpKyspIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTIwLjAuMC4wIFNhZmFyaS81MzcuMzYnLFxyXG4gICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLCovKjtxPTAuOCcsXHJcbiAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogJ2VuLVVTLGVuO3E9MC41JyxcclxuICAgICAgICAgICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZSwgYnInLFxyXG4gICAgICAgICAgJ0Nvbm5lY3Rpb24nOiAna2VlcC1hbGl2ZScsXHJcbiAgICAgICAgICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cyc6ICcxJyxcclxuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEF0dGVtcHQgJHtpICsgMX0gZmFpbGVkIGZvciAke3VybH06YCwgZXJyb3IpXHJcbiAgICAgIGlmIChpID09PSByZXRyaWVzIC0gMSkgdGhyb3cgZXJyb3JcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAgKiAoaSArIDEpKSlcclxuICAgIH1cclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKCdBbGwgcmV0cnkgYXR0ZW1wdHMgZmFpbGVkJylcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VWRVNGcm9tSFRNTChodG1sOiBzdHJpbmcsIHNvdXJjZTogc3RyaW5nKTogUGFydGlhbDxSYXRlc0J1bmRsZT4ge1xyXG4gIGNvbnN0IHJhdGVzOiBQYXJ0aWFsPFJhdGVzQnVuZGxlPiA9IHt9XHJcbiAgXHJcbiAgLy8gTXVsdGlwbGUgcGF0dGVybnMgdG8gdHJ5IGZvciBVU0QvVkVTXHJcbiAgY29uc3QgdXNkUGF0dGVybnMgPSBbXHJcbiAgICAvLyBYRS5jb20gcGF0dGVybnNcclxuICAgIC8xXFxzKlVTRFxccyo9XFxzKihbXFxkLFxcLl0rKVxccypWRVMvaSxcclxuICAgIC9VU0RcXHMqdG9cXHMqVkVTW14+XSo+KFtcXGQsXFwuXSspPC9pLFxyXG4gICAgLy8gV2lzZS5jb20gcGF0dGVybnNcclxuICAgIC8xXFxzKlVTXFxzKmRvbGxhclxccyo9XFxzKihbXFxkLFxcLl0rKVxccypWRVMvaSxcclxuICAgIC9VU0RcXHMqdG9cXHMqVkVTW14+XSo+KFtcXGQsXFwuXSspPC9pLFxyXG4gICAgLy8gR2VuZXJpYyBwYXR0ZXJuc1xyXG4gICAgL1VTRFxccyo9XFxzKihbXFxkLFxcLl0rKVxccypWRVMvaSxcclxuICAgIC8xXFxzKlVTRFxccyo9XFxzKihbXFxkLFxcLl0rKVxccypCb2zDrXZhci9pLFxyXG4gICAgL0TDs2xhclxccyo9XFxzKihbXFxkLFxcLl0rKVxccypCb2zDrXZhci9pXHJcbiAgXVxyXG4gIFxyXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiB1c2RQYXR0ZXJucykge1xyXG4gICAgY29uc3QgbWF0Y2ggPSBodG1sLm1hdGNoKHBhdHRlcm4pXHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgY29uc3QgcmF0ZSA9IHBhcnNlRmxvYXQobWF0Y2hbMV0ucmVwbGFjZSgvLC9nLCAnJykpXHJcbiAgICAgIGlmICghaXNOYU4ocmF0ZSkgJiYgcmF0ZSA+IDUwICYmIHJhdGUgPCAxMDAwKSB7IC8vIFNhbml0eSBjaGVjayBmb3IgcmVhc29uYWJsZSByYW5nZVxyXG4gICAgICAgIHJhdGVzWydVU0QtVkVTJ10gPSB7XHJcbiAgICAgICAgICBiYXNlOiAnVVNEJyxcclxuICAgICAgICAgIHF1b3RlOiAnVkVTJyxcclxuICAgICAgICAgIHZhbHVlOiByYXRlLFxyXG4gICAgICAgICAgcHJvdmlkZXI6IHNvdXJjZSxcclxuICAgICAgICAgIGF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gcmF0ZXNcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VWRVNGcm9tSlNPTihkYXRhOiBhbnksIHNvdXJjZTogc3RyaW5nKTogUGFydGlhbDxSYXRlc0J1bmRsZT4ge1xyXG4gIGNvbnN0IHJhdGVzOiBQYXJ0aWFsPFJhdGVzQnVuZGxlPiA9IHt9XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGxldCB1c2RWZXNSYXRlOiBudW1iZXIgfCBudWxsID0gbnVsbFxyXG4gICAgXHJcbiAgICBpZiAoc291cmNlID09PSAnQ3VycmVuY3lBUEknKSB7XHJcbiAgICAgIGlmIChkYXRhLmRhdGE/LlZFUz8udmFsdWUpIHtcclxuICAgICAgICB1c2RWZXNSYXRlID0gZGF0YS5kYXRhLlZFUy52YWx1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh1c2RWZXNSYXRlICYmIHVzZFZlc1JhdGUgPiA1MCAmJiB1c2RWZXNSYXRlIDwgMTAwMCkge1xyXG4gICAgICByYXRlc1snVVNELVZFUyddID0ge1xyXG4gICAgICAgIGJhc2U6ICdVU0QnLFxyXG4gICAgICAgIHF1b3RlOiAnVkVTJyxcclxuICAgICAgICB2YWx1ZTogdXNkVmVzUmF0ZSxcclxuICAgICAgICBwcm92aWRlcjogc291cmNlLFxyXG4gICAgICAgIGF0OiBkYXRhLm1ldGE/Lmxhc3RfdXBkYXRlZF9hdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwYXJzZSAke3NvdXJjZX0gSlNPTiByZXNwb25zZTpgLCBlcnJvcilcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHJhdGVzXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbHRlcm5hdGl2ZVZFU1JhdGVzKCk6IFByb21pc2U8UHJvdmlkZXJSZXN1bHQ+IHtcclxuICBjb25zdCBhbGxSYXRlczogUmF0ZVtdID0gW11cclxuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW11cclxuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5QVUJMSUNfRlhfQVBJX0tFWVxyXG4gIFxyXG4gIC8vIFRyeSBtdWx0aXBsZSBzb3VyY2VzIGluIHBhcmFsbGVsXHJcbiAgY29uc3Qgc291cmNlUHJvbWlzZXMgPSBBTFRFUk5BVElWRV9WRVNfU09VUkNFUy5tYXAoYXN5bmMgKHNvdXJjZSkgPT4ge1xyXG4gICAgLy8gU2tpcCBzb3VyY2VzIHRoYXQgcmVxdWlyZSBBUEkga2V5IGlmIHdlIGRvbid0IGhhdmUgb25lXHJcbiAgICBpZiAoc291cmNlLm5hbWUgPT09ICdDdXJyZW5jeUFQSScgJiYgIWFwaUtleSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNvdXJjZTogc291cmNlLm5hbWUsXHJcbiAgICAgICAgcmF0ZXM6IFtdLFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiAnQVBJIGtleSByZXF1aXJlZCBidXQgbm90IHByb3ZpZGVkJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGxldCB1cmwgPSBzb3VyY2UudXJsXHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGQgQVBJIGtleSB0byBVUkwgaWYgcmVxdWlyZWRcclxuICAgICAgaWYgKHNvdXJjZS5uYW1lID09PSAnQ3VycmVuY3lBUEknICYmIGFwaUtleSkge1xyXG4gICAgICAgIHVybCA9IGAke3NvdXJjZS51cmx9JmFwaWtleT0ke2FwaUtleX1gXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkodXJsLCB7XHJcbiAgICAgICAgbmV4dDogeyByZXZhbGlkYXRlOiAzNjAwIH1cclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIGlmIChzb3VyY2UucGFyc2VIdG1sKSB7XHJcbiAgICAgICAgY29uc3QgaHRtbCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxyXG4gICAgICAgIGNvbnN0IHJhdGVzID0gcGFyc2VWRVNGcm9tSFRNTChodG1sLCBzb3VyY2UubmFtZSlcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UubmFtZSxcclxuICAgICAgICAgIHJhdGVzOiBPYmplY3QudmFsdWVzKHJhdGVzKSxcclxuICAgICAgICAgIHN1Y2Nlc3M6IE9iamVjdC5rZXlzKHJhdGVzKS5sZW5ndGggPiAwXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICBjb25zdCByYXRlcyA9IHBhcnNlVkVTRnJvbUpTT04oZGF0YSwgc291cmNlLm5hbWUpXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNvdXJjZTogc291cmNlLm5hbWUsXHJcbiAgICAgICAgICByYXRlczogT2JqZWN0LnZhbHVlcyhyYXRlcyksXHJcbiAgICAgICAgICBzdWNjZXNzOiBPYmplY3Qua2V5cyhyYXRlcykubGVuZ3RoID4gMFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGAke3NvdXJjZS5uYW1lfSBmYWlsZWQ6YCwgZXJyb3IpXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc291cmNlOiBzb3VyY2UubmFtZSxcclxuICAgICAgICByYXRlczogW10sXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KVxyXG4gIFxyXG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoc291cmNlUHJvbWlzZXMpXHJcbiAgXHJcbiAgLy8gQ29sbGVjdCBhbGwgc3VjY2Vzc2Z1bCByYXRlc1xyXG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XHJcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgcmVzdWx0LnZhbHVlLnN1Y2Nlc3MpIHtcclxuICAgICAgYWxsUmF0ZXMucHVzaCguLi5yZXN1bHQudmFsdWUucmF0ZXMpXHJcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcpIHtcclxuICAgICAgZXJyb3JzLnB1c2gocmVzdWx0LnJlYXNvbj8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicpXHJcbiAgICB9XHJcbiAgfSlcclxuICBcclxuICBpZiAoYWxsUmF0ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByYXRlczoge30sXHJcbiAgICAgIHByb3ZpZGVyOiAnQWx0ZXJuYXRpdmUtVkVTJyxcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBgQWxsIHNvdXJjZXMgZmFpbGVkOiAke2Vycm9ycy5qb2luKCcsICcpfWBcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gQXZlcmFnZSByYXRlcyBmcm9tIG11bHRpcGxlIHNvdXJjZXNcclxuICBjb25zdCBhdmVyYWdlZFJhdGVzOiBQYXJ0aWFsPFJhdGVzQnVuZGxlPiA9IHt9XHJcbiAgXHJcbiAgY29uc3QgdXNkVmVzUmF0ZXMgPSBhbGxSYXRlcy5maWx0ZXIociA9PiByLmJhc2UgPT09ICdVU0QnICYmIHIucXVvdGUgPT09ICdWRVMnKVxyXG4gIFxyXG4gIGlmICh1c2RWZXNSYXRlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zdCBhdmdVc2RWZXMgPSB1c2RWZXNSYXRlcy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci52YWx1ZSwgMCkgLyB1c2RWZXNSYXRlcy5sZW5ndGhcclxuICAgIGF2ZXJhZ2VkUmF0ZXNbJ1VTRC1WRVMnXSA9IHtcclxuICAgICAgYmFzZTogJ1VTRCcsXHJcbiAgICAgIHF1b3RlOiAnVkVTJyxcclxuICAgICAgdmFsdWU6IGF2Z1VzZFZlcyxcclxuICAgICAgcHJvdmlkZXI6IGBBdmVyYWdlIG9mICR7dXNkVmVzUmF0ZXMubGVuZ3RofSBzb3VyY2VzYCxcclxuICAgICAgYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgcmF0ZXM6IGF2ZXJhZ2VkUmF0ZXMsXHJcbiAgICBwcm92aWRlcjogJ0FsdGVybmF0aXZlLVZFUycsXHJcbiAgICBzdWNjZXNzOiB0cnVlXHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJBTFRFUk5BVElWRV9WRVNfU09VUkNFUyIsIm5hbWUiLCJ1cmwiLCJwYXJzZUh0bWwiLCJmZXRjaFdpdGhSZXRyeSIsIm9wdGlvbnMiLCJyZXRyaWVzIiwiaSIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJwYXJzZVZFU0Zyb21IVE1MIiwiaHRtbCIsInNvdXJjZSIsInJhdGVzIiwidXNkUGF0dGVybnMiLCJwYXR0ZXJuIiwibWF0Y2giLCJyYXRlIiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJpc05hTiIsImJhc2UiLCJxdW90ZSIsInZhbHVlIiwicHJvdmlkZXIiLCJhdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInBhcnNlVkVTRnJvbUpTT04iLCJkYXRhIiwidXNkVmVzUmF0ZSIsIlZFUyIsIm1ldGEiLCJsYXN0X3VwZGF0ZWRfYXQiLCJnZXRBbHRlcm5hdGl2ZVZFU1JhdGVzIiwiYWxsUmF0ZXMiLCJlcnJvcnMiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiUFVCTElDX0ZYX0FQSV9LRVkiLCJzb3VyY2VQcm9taXNlcyIsIm1hcCIsInN1Y2Nlc3MiLCJuZXh0IiwicmV2YWxpZGF0ZSIsInRleHQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJrZXlzIiwibGVuZ3RoIiwianNvbiIsIm1lc3NhZ2UiLCJyZXN1bHRzIiwiYWxsU2V0dGxlZCIsImZvckVhY2giLCJyZXN1bHQiLCJzdGF0dXMiLCJwdXNoIiwicmVhc29uIiwiam9pbiIsImF2ZXJhZ2VkUmF0ZXMiLCJ1c2RWZXNSYXRlcyIsImZpbHRlciIsInIiLCJhdmdVc2RWZXMiLCJyZWR1Y2UiLCJzdW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/rates/providers/alternativeVes.ts\n");

/***/ })

});