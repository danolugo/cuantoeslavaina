"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/api/rates/route",{

/***/ "(rsc)/./src/lib/rates/compose.ts":
/*!**********************************!*\
  !*** ./src/lib/rates/compose.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   composeRates: () => (/* binding */ composeRates),\n/* harmony export */   computeCrossRate: () => (/* binding */ computeCrossRate),\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   createRateKey: () => (/* binding */ createRateKey),\n/* harmony export */   getInverseRate: () => (/* binding */ getInverseRate),\n/* harmony export */   roundToSignificantDigits: () => (/* binding */ roundToSignificantDigits)\n/* harmony export */ });\n/* harmony import */ var _providers_bcv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./providers/bcv */ \"(rsc)/./src/lib/rates/providers/bcv.ts\");\n/* harmony import */ var _providers_frankfurter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./providers/frankfurter */ \"(rsc)/./src/lib/rates/providers/frankfurter.ts\");\n/* harmony import */ var _providers_publicFx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./providers/publicFx */ \"(rsc)/./src/lib/rates/providers/publicFx.ts\");\n\n\n\nfunction createRateKey(base, quote) {\n    return `${base}-${quote}`;\n}\nfunction getInverseRate(rate) {\n    return {\n        base: rate.quote,\n        quote: rate.base,\n        value: 1 / rate.value,\n        provider: rate.provider,\n        at: rate.at\n    };\n}\nfunction roundToSignificantDigits(value, digits = 6) {\n    if (value === 0) return 0;\n    const magnitude = Math.floor(Math.log10(Math.abs(value)));\n    const factor = Math.pow(10, digits - 1 - magnitude);\n    return Math.round(value * factor) / factor;\n}\nfunction computeCrossRate(rate1, rate2, targetBase, targetQuote) {\n    // Check if we can compute the cross rate\n    if (rate1.quote !== rate2.base) {\n        return null;\n    }\n    const crossValue = rate1.value * rate2.value;\n    const roundedValue = roundToSignificantDigits(crossValue);\n    return {\n        base: targetBase,\n        quote: targetQuote,\n        value: roundedValue,\n        provider: `${rate1.provider}+${rate2.provider}`,\n        at: new Date().toISOString()\n    };\n}\nasync function composeRates() {\n    const allRates = {};\n    const providerNotes = [];\n    // Fetch from all providers in parallel\n    const [bcvResult, frankfurterResult, publicFxResult] = await Promise.allSettled([\n        (0,_providers_bcv__WEBPACK_IMPORTED_MODULE_0__.getBCVRates)(),\n        (0,_providers_frankfurter__WEBPACK_IMPORTED_MODULE_1__.getFrankfurterRates)(),\n        (0,_providers_publicFx__WEBPACK_IMPORTED_MODULE_2__.getPublicFxRates)()\n    ]);\n    // Process BCV results\n    if (bcvResult.status === \"fulfilled\" && bcvResult.value.success) {\n        Object.assign(allRates, bcvResult.value.rates);\n        providerNotes.push(`BCV: ${Object.keys(bcvResult.value.rates).length} rates`);\n    } else {\n        const error = bcvResult.status === \"rejected\" ? bcvResult.reason?.message : bcvResult.value?.error;\n        providerNotes.push(`BCV: Failed (${error})`);\n    }\n    // Process Frankfurter results\n    if (frankfurterResult.status === \"fulfilled\" && frankfurterResult.value.success) {\n        Object.assign(allRates, frankfurterResult.value.rates);\n        providerNotes.push(`Frankfurter: ${Object.keys(frankfurterResult.value.rates).length} rates`);\n    } else {\n        const error = frankfurterResult.status === \"rejected\" ? frankfurterResult.reason?.message : frankfurterResult.value?.error;\n        providerNotes.push(`Frankfurter: Failed (${error})`);\n    }\n    // Process Public FX results\n    if (publicFxResult.status === \"fulfilled\" && publicFxResult.value.success) {\n        Object.assign(allRates, publicFxResult.value.rates);\n        providerNotes.push(`PublicFX: ${Object.keys(publicFxResult.value.rates).length} rates`);\n    } else {\n        const error = publicFxResult.status === \"rejected\" ? publicFxResult.reason?.message : publicFxResult.value?.error;\n        providerNotes.push(`PublicFX: Failed (${error})`);\n    }\n    // Add inverse rates for all direct rates\n    const directRates = {\n        ...allRates\n    };\n    for (const [key, rate] of Object.entries(directRates)){\n        const inverseKey = createRateKey(rate.quote, rate.base);\n        if (!allRates[inverseKey]) {\n            allRates[inverseKey] = getInverseRate(rate);\n        }\n    }\n    // Add fallback rates if we have very few rates\n    if (Object.keys(allRates).length < 4) {\n        providerNotes.push(\"Using fallback rates due to limited data\");\n        // Add some reasonable fallback rates for testing\n        if (!allRates[\"USD-VES\"]) {\n            allRates[\"USD-VES\"] = {\n                base: \"USD\",\n                quote: \"VES\",\n                value: 195.0,\n                provider: \"Fallback\",\n                at: new Date().toISOString()\n            };\n            allRates[\"VES-USD\"] = getInverseRate(allRates[\"USD-VES\"]);\n        }\n        if (!allRates[\"USD-COP\"]) {\n            allRates[\"USD-COP\"] = {\n                base: \"USD\",\n                quote: \"COP\",\n                value: 4100,\n                provider: \"Fallback\",\n                at: new Date().toISOString()\n            };\n            allRates[\"COP-USD\"] = getInverseRate(allRates[\"USD-COP\"]);\n        }\n    }\n    // Compute cross rates for missing pairs\n    const requiredPairs = [\n        \"COP-VES\",\n        \"VES-COP\"\n    ];\n    for (const pair of requiredPairs){\n        if (!allRates[pair]) {\n            const [base, quote] = pair.split(\"-\");\n            // Try COP-VES via COP-USD and USD-VES\n            if (base === \"COP\" && quote === \"VES\") {\n                const copUsd = allRates[\"COP-USD\"];\n                const usdVes = allRates[\"USD-VES\"];\n                if (copUsd && usdVes) {\n                    const crossRate = computeCrossRate(copUsd, usdVes, \"COP\", \"VES\");\n                    if (crossRate) {\n                        allRates[\"COP-VES\"] = crossRate;\n                        allRates[\"VES-COP\"] = getInverseRate(crossRate);\n                        providerNotes.push(\"COP-VES: Computed via COP-USD \\xd7 USD-VES\");\n                    }\n                }\n            }\n        }\n    }\n    return allRates;\n}\nfunction convert(amount, from, to, rates) {\n    if (from === to) return amount;\n    const directKey = createRateKey(from, to);\n    const directRate = rates[directKey];\n    if (directRate) {\n        return roundToSignificantDigits(amount * directRate.value, 8);\n    }\n    // Try cross conversion via USD (most reliable base currency)\n    const fromUsdKey = createRateKey(from, \"USD\");\n    const usdToKey = createRateKey(\"USD\", to);\n    if (rates[fromUsdKey] && rates[usdToKey]) {\n        const viaUsd = amount * rates[fromUsdKey].value * rates[usdToKey].value;\n        return roundToSignificantDigits(viaUsd, 8);\n    }\n    // Try cross conversion via EUR\n    const fromEurKey = createRateKey(from, \"EUR\");\n    const eurToKey = createRateKey(\"EUR\", to);\n    if (rates[fromEurKey] && rates[eurToKey]) {\n        const viaEur = amount * rates[fromEurKey].value * rates[eurToKey].value;\n        return roundToSignificantDigits(viaEur, 8);\n    }\n    // Try cross conversion via COP (for VES-COP specifically)\n    if (from === \"VES\" && to === \"COP\") {\n        const vesUsdKey = createRateKey(\"VES\", \"USD\");\n        const usdCopKey = createRateKey(\"USD\", \"COP\");\n        if (rates[vesUsdKey] && rates[usdCopKey]) {\n            const viaUsd = amount * rates[vesUsdKey].value * rates[usdCopKey].value;\n            return roundToSignificantDigits(viaUsd, 8);\n        }\n    }\n    if (from === \"COP\" && to === \"VES\") {\n        const copUsdKey = createRateKey(\"COP\", \"USD\");\n        const usdVesKey = createRateKey(\"USD\", \"VES\");\n        if (rates[copUsdKey] && rates[usdVesKey]) {\n            const viaUsd = amount * rates[copUsdKey].value * rates[usdVesKey].value;\n            return roundToSignificantDigits(viaUsd, 8);\n        }\n    }\n    // Try multi-hop conversion: VES -> USD -> EUR -> Target\n    if (from === \"VES\" && (to === \"EUR\" || to === \"COP\")) {\n        const vesUsdKey = createRateKey(\"VES\", \"USD\");\n        const usdEurKey = createRateKey(\"USD\", \"EUR\");\n        const eurTargetKey = createRateKey(\"EUR\", to);\n        if (rates[vesUsdKey] && rates[usdEurKey] && rates[eurTargetKey]) {\n            const viaUsdEur = amount * rates[vesUsdKey].value * rates[usdEurKey].value * rates[eurTargetKey].value;\n            return roundToSignificantDigits(viaUsdEur, 8);\n        }\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b250ZW50IjpbImltcG9ydCB7IEN1cnJlbmN5LCBSYXRlLCBSYXRlc0J1bmRsZSB9IGZyb20gJy4vdHlwZXMnXHJcbmltcG9ydCB7IGdldEJDVlJhdGVzIH0gZnJvbSAnLi9wcm92aWRlcnMvYmN2J1xyXG5pbXBvcnQgeyBnZXRGcmFua2Z1cnRlclJhdGVzIH0gZnJvbSAnLi9wcm92aWRlcnMvZnJhbmtmdXJ0ZXInXHJcbmltcG9ydCB7IGdldFB1YmxpY0Z4UmF0ZXMgfSBmcm9tICcuL3Byb3ZpZGVycy9wdWJsaWNGeCdcclxuaW1wb3J0IHsgZ2V0QWx0ZXJuYXRpdmVWRVNSYXRlcyB9IGZyb20gJy4vcHJvdmlkZXJzL2FsdGVybmF0aXZlVmVzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhdGVLZXkoYmFzZTogQ3VycmVuY3ksIHF1b3RlOiBDdXJyZW5jeSk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGAke2Jhc2V9LSR7cXVvdGV9YFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW52ZXJzZVJhdGUocmF0ZTogUmF0ZSk6IFJhdGUge1xyXG4gIHJldHVybiB7XHJcbiAgICBiYXNlOiByYXRlLnF1b3RlLFxyXG4gICAgcXVvdGU6IHJhdGUuYmFzZSxcclxuICAgIHZhbHVlOiAxIC8gcmF0ZS52YWx1ZSxcclxuICAgIHByb3ZpZGVyOiByYXRlLnByb3ZpZGVyLFxyXG4gICAgYXQ6IHJhdGUuYXRcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvU2lnbmlmaWNhbnREaWdpdHModmFsdWU6IG51bWJlciwgZGlnaXRzOiBudW1iZXIgPSA2KTogbnVtYmVyIHtcclxuICBpZiAodmFsdWUgPT09IDApIHJldHVybiAwXHJcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE1hdGguYWJzKHZhbHVlKSkpXHJcbiAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coMTAsIGRpZ2l0cyAtIDEgLSBtYWduaXR1ZGUpXHJcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBmYWN0b3IpIC8gZmFjdG9yXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQ3Jvc3NSYXRlKFxyXG4gIHJhdGUxOiBSYXRlLFxyXG4gIHJhdGUyOiBSYXRlLFxyXG4gIHRhcmdldEJhc2U6IEN1cnJlbmN5LFxyXG4gIHRhcmdldFF1b3RlOiBDdXJyZW5jeVxyXG4pOiBSYXRlIHwgbnVsbCB7XHJcbiAgLy8gQ2hlY2sgaWYgd2UgY2FuIGNvbXB1dGUgdGhlIGNyb3NzIHJhdGVcclxuICBpZiAocmF0ZTEucXVvdGUgIT09IHJhdGUyLmJhc2UpIHtcclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IGNyb3NzVmFsdWUgPSByYXRlMS52YWx1ZSAqIHJhdGUyLnZhbHVlXHJcbiAgY29uc3Qgcm91bmRlZFZhbHVlID0gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKGNyb3NzVmFsdWUpXHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGJhc2U6IHRhcmdldEJhc2UsXHJcbiAgICBxdW90ZTogdGFyZ2V0UXVvdGUsXHJcbiAgICB2YWx1ZTogcm91bmRlZFZhbHVlLFxyXG4gICAgcHJvdmlkZXI6IGAke3JhdGUxLnByb3ZpZGVyfSske3JhdGUyLnByb3ZpZGVyfWAsXHJcbiAgICBhdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcG9zZVJhdGVzKCk6IFByb21pc2U8UmF0ZXNCdW5kbGU+IHtcclxuICBjb25zdCBhbGxSYXRlczogUmF0ZXNCdW5kbGUgPSB7fVxyXG4gIGNvbnN0IHByb3ZpZGVyTm90ZXM6IHN0cmluZ1tdID0gW11cclxuICBcclxuICAvLyBGZXRjaCBmcm9tIGFsbCBwcm92aWRlcnMgaW4gcGFyYWxsZWxcclxuICBjb25zdCBbYmN2UmVzdWx0LCBmcmFua2Z1cnRlclJlc3VsdCwgcHVibGljRnhSZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtcclxuICAgIGdldEJDVlJhdGVzKCksXHJcbiAgICBnZXRGcmFua2Z1cnRlclJhdGVzKCksXHJcbiAgICBnZXRQdWJsaWNGeFJhdGVzKClcclxuICBdKVxyXG4gIFxyXG4gIC8vIFByb2Nlc3MgQkNWIHJlc3VsdHNcclxuICBpZiAoYmN2UmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgYmN2UmVzdWx0LnZhbHVlLnN1Y2Nlc3MpIHtcclxuICAgIE9iamVjdC5hc3NpZ24oYWxsUmF0ZXMsIGJjdlJlc3VsdC52YWx1ZS5yYXRlcylcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaChgQkNWOiAke09iamVjdC5rZXlzKGJjdlJlc3VsdC52YWx1ZS5yYXRlcykubGVuZ3RofSByYXRlc2ApXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGVycm9yID0gYmN2UmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJyA/IGJjdlJlc3VsdC5yZWFzb24/Lm1lc3NhZ2UgOiBiY3ZSZXN1bHQudmFsdWU/LmVycm9yXHJcbiAgICBwcm92aWRlck5vdGVzLnB1c2goYEJDVjogRmFpbGVkICgke2Vycm9yfSlgKVxyXG4gIH1cclxuICBcclxuICAvLyBQcm9jZXNzIEZyYW5rZnVydGVyIHJlc3VsdHNcclxuICBpZiAoZnJhbmtmdXJ0ZXJSZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJyAmJiBmcmFua2Z1cnRlclJlc3VsdC52YWx1ZS5zdWNjZXNzKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKGFsbFJhdGVzLCBmcmFua2Z1cnRlclJlc3VsdC52YWx1ZS5yYXRlcylcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaChgRnJhbmtmdXJ0ZXI6ICR7T2JqZWN0LmtleXMoZnJhbmtmdXJ0ZXJSZXN1bHQudmFsdWUucmF0ZXMpLmxlbmd0aH0gcmF0ZXNgKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBlcnJvciA9IGZyYW5rZnVydGVyUmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJyA/IGZyYW5rZnVydGVyUmVzdWx0LnJlYXNvbj8ubWVzc2FnZSA6IGZyYW5rZnVydGVyUmVzdWx0LnZhbHVlPy5lcnJvclxyXG4gICAgcHJvdmlkZXJOb3Rlcy5wdXNoKGBGcmFua2Z1cnRlcjogRmFpbGVkICgke2Vycm9yfSlgKVxyXG4gIH1cclxuICBcclxuICAvLyBQcm9jZXNzIFB1YmxpYyBGWCByZXN1bHRzXHJcbiAgaWYgKHB1YmxpY0Z4UmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgcHVibGljRnhSZXN1bHQudmFsdWUuc3VjY2Vzcykge1xyXG4gICAgT2JqZWN0LmFzc2lnbihhbGxSYXRlcywgcHVibGljRnhSZXN1bHQudmFsdWUucmF0ZXMpXHJcbiAgICBwcm92aWRlck5vdGVzLnB1c2goYFB1YmxpY0ZYOiAke09iamVjdC5rZXlzKHB1YmxpY0Z4UmVzdWx0LnZhbHVlLnJhdGVzKS5sZW5ndGh9IHJhdGVzYClcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgZXJyb3IgPSBwdWJsaWNGeFJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcgPyBwdWJsaWNGeFJlc3VsdC5yZWFzb24/Lm1lc3NhZ2UgOiBwdWJsaWNGeFJlc3VsdC52YWx1ZT8uZXJyb3JcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaChgUHVibGljRlg6IEZhaWxlZCAoJHtlcnJvcn0pYClcclxuICB9XHJcbiAgXHJcbiAgLy8gQWRkIGludmVyc2UgcmF0ZXMgZm9yIGFsbCBkaXJlY3QgcmF0ZXNcclxuICBjb25zdCBkaXJlY3RSYXRlcyA9IHsgLi4uYWxsUmF0ZXMgfVxyXG4gIGZvciAoY29uc3QgW2tleSwgcmF0ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGlyZWN0UmF0ZXMpKSB7XHJcbiAgICBjb25zdCBpbnZlcnNlS2V5ID0gY3JlYXRlUmF0ZUtleShyYXRlLnF1b3RlLCByYXRlLmJhc2UpXHJcbiAgICBpZiAoIWFsbFJhdGVzW2ludmVyc2VLZXldKSB7XHJcbiAgICAgIGFsbFJhdGVzW2ludmVyc2VLZXldID0gZ2V0SW52ZXJzZVJhdGUocmF0ZSlcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gQWRkIGZhbGxiYWNrIHJhdGVzIGlmIHdlIGhhdmUgdmVyeSBmZXcgcmF0ZXNcclxuICBpZiAoT2JqZWN0LmtleXMoYWxsUmF0ZXMpLmxlbmd0aCA8IDQpIHtcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaCgnVXNpbmcgZmFsbGJhY2sgcmF0ZXMgZHVlIHRvIGxpbWl0ZWQgZGF0YScpXHJcbiAgICBcclxuICAgIC8vIEFkZCBzb21lIHJlYXNvbmFibGUgZmFsbGJhY2sgcmF0ZXMgZm9yIHRlc3RpbmdcclxuICAgIGlmICghYWxsUmF0ZXNbJ1VTRC1WRVMnXSkge1xyXG4gICAgICBhbGxSYXRlc1snVVNELVZFUyddID0ge1xyXG4gICAgICAgIGJhc2U6ICdVU0QnLFxyXG4gICAgICAgIHF1b3RlOiAnVkVTJyxcclxuICAgICAgICB2YWx1ZTogMTk1LjAsIC8vIFVwZGF0ZWQgYXBwcm94aW1hdGUgcmF0ZSAoT2N0b2JlciAyMDI0KVxyXG4gICAgICAgIHByb3ZpZGVyOiAnRmFsbGJhY2snLFxyXG4gICAgICAgIGF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfVxyXG4gICAgICBhbGxSYXRlc1snVkVTLVVTRCddID0gZ2V0SW52ZXJzZVJhdGUoYWxsUmF0ZXNbJ1VTRC1WRVMnXSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKCFhbGxSYXRlc1snVVNELUNPUCddKSB7XHJcbiAgICAgIGFsbFJhdGVzWydVU0QtQ09QJ10gPSB7XHJcbiAgICAgICAgYmFzZTogJ1VTRCcsXHJcbiAgICAgICAgcXVvdGU6ICdDT1AnLFxyXG4gICAgICAgIHZhbHVlOiA0MTAwLCAvLyBBcHByb3hpbWF0ZSByYXRlXHJcbiAgICAgICAgcHJvdmlkZXI6ICdGYWxsYmFjaycsXHJcbiAgICAgICAgYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9XHJcbiAgICAgIGFsbFJhdGVzWydDT1AtVVNEJ10gPSBnZXRJbnZlcnNlUmF0ZShhbGxSYXRlc1snVVNELUNPUCddKVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBDb21wdXRlIGNyb3NzIHJhdGVzIGZvciBtaXNzaW5nIHBhaXJzXHJcbiAgY29uc3QgcmVxdWlyZWRQYWlycyA9IFtcclxuICAgICdDT1AtVkVTJywgJ1ZFUy1DT1AnXHJcbiAgXVxyXG4gIFxyXG4gIGZvciAoY29uc3QgcGFpciBvZiByZXF1aXJlZFBhaXJzKSB7XHJcbiAgICBpZiAoIWFsbFJhdGVzW3BhaXJdKSB7XHJcbiAgICAgIGNvbnN0IFtiYXNlLCBxdW90ZV0gPSBwYWlyLnNwbGl0KCctJykgYXMgW0N1cnJlbmN5LCBDdXJyZW5jeV1cclxuICAgICAgXHJcbiAgICAgIC8vIFRyeSBDT1AtVkVTIHZpYSBDT1AtVVNEIGFuZCBVU0QtVkVTXHJcbiAgICAgIGlmIChiYXNlID09PSAnQ09QJyAmJiBxdW90ZSA9PT0gJ1ZFUycpIHtcclxuICAgICAgICBjb25zdCBjb3BVc2QgPSBhbGxSYXRlc1snQ09QLVVTRCddXHJcbiAgICAgICAgY29uc3QgdXNkVmVzID0gYWxsUmF0ZXNbJ1VTRC1WRVMnXVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjb3BVc2QgJiYgdXNkVmVzKSB7XHJcbiAgICAgICAgICBjb25zdCBjcm9zc1JhdGUgPSBjb21wdXRlQ3Jvc3NSYXRlKGNvcFVzZCwgdXNkVmVzLCAnQ09QJywgJ1ZFUycpXHJcbiAgICAgICAgICBpZiAoY3Jvc3NSYXRlKSB7XHJcbiAgICAgICAgICAgIGFsbFJhdGVzWydDT1AtVkVTJ10gPSBjcm9zc1JhdGVcclxuICAgICAgICAgICAgYWxsUmF0ZXNbJ1ZFUy1DT1AnXSA9IGdldEludmVyc2VSYXRlKGNyb3NzUmF0ZSlcclxuICAgICAgICAgICAgcHJvdmlkZXJOb3Rlcy5wdXNoKCdDT1AtVkVTOiBDb21wdXRlZCB2aWEgQ09QLVVTRCDDlyBVU0QtVkVTJylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGFsbFJhdGVzXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0KFxyXG4gIGFtb3VudDogbnVtYmVyLFxyXG4gIGZyb206IEN1cnJlbmN5LFxyXG4gIHRvOiBDdXJyZW5jeSxcclxuICByYXRlczogUmF0ZXNCdW5kbGVcclxuKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gYW1vdW50XHJcbiAgXHJcbiAgY29uc3QgZGlyZWN0S2V5ID0gY3JlYXRlUmF0ZUtleShmcm9tLCB0bylcclxuICBjb25zdCBkaXJlY3RSYXRlID0gcmF0ZXNbZGlyZWN0S2V5XVxyXG4gIFxyXG4gIGlmIChkaXJlY3RSYXRlKSB7XHJcbiAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKGFtb3VudCAqIGRpcmVjdFJhdGUudmFsdWUsIDgpXHJcbiAgfVxyXG4gIFxyXG4gIC8vIFRyeSBjcm9zcyBjb252ZXJzaW9uIHZpYSBVU0QgKG1vc3QgcmVsaWFibGUgYmFzZSBjdXJyZW5jeSlcclxuICBjb25zdCBmcm9tVXNkS2V5ID0gY3JlYXRlUmF0ZUtleShmcm9tLCAnVVNEJylcclxuICBjb25zdCB1c2RUb0tleSA9IGNyZWF0ZVJhdGVLZXkoJ1VTRCcsIHRvKVxyXG4gIFxyXG4gIGlmIChyYXRlc1tmcm9tVXNkS2V5XSAmJiByYXRlc1t1c2RUb0tleV0pIHtcclxuICAgIGNvbnN0IHZpYVVzZCA9IGFtb3VudCAqIHJhdGVzW2Zyb21Vc2RLZXldLnZhbHVlICogcmF0ZXNbdXNkVG9LZXldLnZhbHVlXHJcbiAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZpYVVzZCwgOClcclxuICB9XHJcbiAgXHJcbiAgLy8gVHJ5IGNyb3NzIGNvbnZlcnNpb24gdmlhIEVVUlxyXG4gIGNvbnN0IGZyb21FdXJLZXkgPSBjcmVhdGVSYXRlS2V5KGZyb20sICdFVVInKVxyXG4gIGNvbnN0IGV1clRvS2V5ID0gY3JlYXRlUmF0ZUtleSgnRVVSJywgdG8pXHJcbiAgXHJcbiAgaWYgKHJhdGVzW2Zyb21FdXJLZXldICYmIHJhdGVzW2V1clRvS2V5XSkge1xyXG4gICAgY29uc3QgdmlhRXVyID0gYW1vdW50ICogcmF0ZXNbZnJvbUV1cktleV0udmFsdWUgKiByYXRlc1tldXJUb0tleV0udmFsdWVcclxuICAgIHJldHVybiByb3VuZFRvU2lnbmlmaWNhbnREaWdpdHModmlhRXVyLCA4KVxyXG4gIH1cclxuICBcclxuICAvLyBUcnkgY3Jvc3MgY29udmVyc2lvbiB2aWEgQ09QIChmb3IgVkVTLUNPUCBzcGVjaWZpY2FsbHkpXHJcbiAgaWYgKGZyb20gPT09ICdWRVMnICYmIHRvID09PSAnQ09QJykge1xyXG4gICAgY29uc3QgdmVzVXNkS2V5ID0gY3JlYXRlUmF0ZUtleSgnVkVTJywgJ1VTRCcpXHJcbiAgICBjb25zdCB1c2RDb3BLZXkgPSBjcmVhdGVSYXRlS2V5KCdVU0QnLCAnQ09QJylcclxuICAgIFxyXG4gICAgaWYgKHJhdGVzW3Zlc1VzZEtleV0gJiYgcmF0ZXNbdXNkQ29wS2V5XSkge1xyXG4gICAgICBjb25zdCB2aWFVc2QgPSBhbW91bnQgKiByYXRlc1t2ZXNVc2RLZXldLnZhbHVlICogcmF0ZXNbdXNkQ29wS2V5XS52YWx1ZVxyXG4gICAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZpYVVzZCwgOClcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgaWYgKGZyb20gPT09ICdDT1AnICYmIHRvID09PSAnVkVTJykge1xyXG4gICAgY29uc3QgY29wVXNkS2V5ID0gY3JlYXRlUmF0ZUtleSgnQ09QJywgJ1VTRCcpXHJcbiAgICBjb25zdCB1c2RWZXNLZXkgPSBjcmVhdGVSYXRlS2V5KCdVU0QnLCAnVkVTJylcclxuICAgIFxyXG4gICAgaWYgKHJhdGVzW2NvcFVzZEtleV0gJiYgcmF0ZXNbdXNkVmVzS2V5XSkge1xyXG4gICAgICBjb25zdCB2aWFVc2QgPSBhbW91bnQgKiByYXRlc1tjb3BVc2RLZXldLnZhbHVlICogcmF0ZXNbdXNkVmVzS2V5XS52YWx1ZVxyXG4gICAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZpYVVzZCwgOClcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gVHJ5IG11bHRpLWhvcCBjb252ZXJzaW9uOiBWRVMgLT4gVVNEIC0+IEVVUiAtPiBUYXJnZXRcclxuICBpZiAoZnJvbSA9PT0gJ1ZFUycgJiYgKHRvID09PSAnRVVSJyB8fCB0byA9PT0gJ0NPUCcpKSB7XHJcbiAgICBjb25zdCB2ZXNVc2RLZXkgPSBjcmVhdGVSYXRlS2V5KCdWRVMnLCAnVVNEJylcclxuICAgIGNvbnN0IHVzZEV1cktleSA9IGNyZWF0ZVJhdGVLZXkoJ1VTRCcsICdFVVInKVxyXG4gICAgY29uc3QgZXVyVGFyZ2V0S2V5ID0gY3JlYXRlUmF0ZUtleSgnRVVSJywgdG8pXHJcbiAgICBcclxuICAgIGlmIChyYXRlc1t2ZXNVc2RLZXldICYmIHJhdGVzW3VzZEV1cktleV0gJiYgcmF0ZXNbZXVyVGFyZ2V0S2V5XSkge1xyXG4gICAgICBjb25zdCB2aWFVc2RFdXIgPSBhbW91bnQgKiByYXRlc1t2ZXNVc2RLZXldLnZhbHVlICogcmF0ZXNbdXNkRXVyS2V5XS52YWx1ZSAqIHJhdGVzW2V1clRhcmdldEtleV0udmFsdWVcclxuICAgICAgcmV0dXJuIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyh2aWFVc2RFdXIsIDgpXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBudWxsXHJcbn1cclxuIl0sIm5hbWVzIjpbImdldEJDVlJhdGVzIiwiZ2V0RnJhbmtmdXJ0ZXJSYXRlcyIsImdldFB1YmxpY0Z4UmF0ZXMiLCJjcmVhdGVSYXRlS2V5IiwiYmFzZSIsInF1b3RlIiwiZ2V0SW52ZXJzZVJhdGUiLCJyYXRlIiwidmFsdWUiLCJwcm92aWRlciIsImF0Iiwicm91bmRUb1NpZ25pZmljYW50RGlnaXRzIiwiZGlnaXRzIiwibWFnbml0dWRlIiwiTWF0aCIsImZsb29yIiwibG9nMTAiLCJhYnMiLCJmYWN0b3IiLCJwb3ciLCJyb3VuZCIsImNvbXB1dGVDcm9zc1JhdGUiLCJyYXRlMSIsInJhdGUyIiwidGFyZ2V0QmFzZSIsInRhcmdldFF1b3RlIiwiY3Jvc3NWYWx1ZSIsInJvdW5kZWRWYWx1ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbXBvc2VSYXRlcyIsImFsbFJhdGVzIiwicHJvdmlkZXJOb3RlcyIsImJjdlJlc3VsdCIsImZyYW5rZnVydGVyUmVzdWx0IiwicHVibGljRnhSZXN1bHQiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsInN0YXR1cyIsInN1Y2Nlc3MiLCJPYmplY3QiLCJhc3NpZ24iLCJyYXRlcyIsInB1c2giLCJrZXlzIiwibGVuZ3RoIiwiZXJyb3IiLCJyZWFzb24iLCJtZXNzYWdlIiwiZGlyZWN0UmF0ZXMiLCJrZXkiLCJlbnRyaWVzIiwiaW52ZXJzZUtleSIsInJlcXVpcmVkUGFpcnMiLCJwYWlyIiwic3BsaXQiLCJjb3BVc2QiLCJ1c2RWZXMiLCJjcm9zc1JhdGUiLCJjb252ZXJ0IiwiYW1vdW50IiwiZnJvbSIsInRvIiwiZGlyZWN0S2V5IiwiZGlyZWN0UmF0ZSIsImZyb21Vc2RLZXkiLCJ1c2RUb0tleSIsInZpYVVzZCIsImZyb21FdXJLZXkiLCJldXJUb0tleSIsInZpYUV1ciIsInZlc1VzZEtleSIsInVzZENvcEtleSIsImNvcFVzZEtleSIsInVzZFZlc0tleSIsInVzZEV1cktleSIsImV1clRhcmdldEtleSIsInZpYVVzZEV1ciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/rates/compose.ts\n");

/***/ })

});