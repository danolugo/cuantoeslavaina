"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/rates/compose.ts":
/*!**********************************!*\
  !*** ./src/lib/rates/compose.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   composeRates: function() { return /* binding */ composeRates; },\n/* harmony export */   computeCrossRate: function() { return /* binding */ computeCrossRate; },\n/* harmony export */   convert: function() { return /* binding */ convert; },\n/* harmony export */   createRateKey: function() { return /* binding */ createRateKey; },\n/* harmony export */   getInverseRate: function() { return /* binding */ getInverseRate; },\n/* harmony export */   roundToSignificantDigits: function() { return /* binding */ roundToSignificantDigits; }\n/* harmony export */ });\n/* harmony import */ var _providers_bcv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./providers/bcv */ \"(app-pages-browser)/./src/lib/rates/providers/bcv.ts\");\n/* harmony import */ var _providers_frankfurter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./providers/frankfurter */ \"(app-pages-browser)/./src/lib/rates/providers/frankfurter.ts\");\n/* harmony import */ var _providers_publicFx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./providers/publicFx */ \"(app-pages-browser)/./src/lib/rates/providers/publicFx.ts\");\n/* harmony import */ var _providers_alternativeVes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./providers/alternativeVes */ \"(app-pages-browser)/./src/lib/rates/providers/alternativeVes.ts\");\n\n\n\n\nfunction createRateKey(base, quote) {\n    return \"\".concat(base, \"-\").concat(quote);\n}\nfunction getInverseRate(rate) {\n    return {\n        base: rate.quote,\n        quote: rate.base,\n        value: 1 / rate.value,\n        provider: rate.provider,\n        at: rate.at\n    };\n}\nfunction roundToSignificantDigits(value) {\n    let digits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;\n    if (value === 0) return 0;\n    const magnitude = Math.floor(Math.log10(Math.abs(value)));\n    const factor = Math.pow(10, digits - 1 - magnitude);\n    return Math.round(value * factor) / factor;\n}\nfunction computeCrossRate(rate1, rate2, targetBase, targetQuote) {\n    // Check if we can compute the cross rate\n    if (rate1.quote !== rate2.base) {\n        return null;\n    }\n    const crossValue = rate1.value * rate2.value;\n    const roundedValue = roundToSignificantDigits(crossValue);\n    return {\n        base: targetBase,\n        quote: targetQuote,\n        value: roundedValue,\n        provider: \"\".concat(rate1.provider, \"+\").concat(rate2.provider),\n        at: new Date().toISOString()\n    };\n}\nasync function composeRates() {\n    const allRates = {};\n    const providerNotes = [];\n    // Fetch from all providers in parallel\n    const [bcvResult, frankfurterResult, publicFxResult, alternativeVesResult] = await Promise.allSettled([\n        (0,_providers_bcv__WEBPACK_IMPORTED_MODULE_0__.getBCVRates)(),\n        (0,_providers_frankfurter__WEBPACK_IMPORTED_MODULE_1__.getFrankfurterRates)(),\n        (0,_providers_publicFx__WEBPACK_IMPORTED_MODULE_2__.getPublicFxRates)(),\n        (0,_providers_alternativeVes__WEBPACK_IMPORTED_MODULE_3__.getAlternativeVESRates)()\n    ]);\n    // Process BCV results\n    if (bcvResult.status === \"fulfilled\" && bcvResult.value.success) {\n        Object.assign(allRates, bcvResult.value.rates);\n        providerNotes.push(\"BCV: \".concat(Object.keys(bcvResult.value.rates).length, \" rates\"));\n    } else {\n        var _bcvResult_reason, _bcvResult_value;\n        const error = bcvResult.status === \"rejected\" ? (_bcvResult_reason = bcvResult.reason) === null || _bcvResult_reason === void 0 ? void 0 : _bcvResult_reason.message : (_bcvResult_value = bcvResult.value) === null || _bcvResult_value === void 0 ? void 0 : _bcvResult_value.error;\n        providerNotes.push(\"BCV: Failed (\".concat(error, \")\"));\n    }\n    // Process Frankfurter results\n    if (frankfurterResult.status === \"fulfilled\" && frankfurterResult.value.success) {\n        Object.assign(allRates, frankfurterResult.value.rates);\n        providerNotes.push(\"Frankfurter: \".concat(Object.keys(frankfurterResult.value.rates).length, \" rates\"));\n    } else {\n        var _frankfurterResult_reason, _frankfurterResult_value;\n        const error = frankfurterResult.status === \"rejected\" ? (_frankfurterResult_reason = frankfurterResult.reason) === null || _frankfurterResult_reason === void 0 ? void 0 : _frankfurterResult_reason.message : (_frankfurterResult_value = frankfurterResult.value) === null || _frankfurterResult_value === void 0 ? void 0 : _frankfurterResult_value.error;\n        providerNotes.push(\"Frankfurter: Failed (\".concat(error, \")\"));\n    }\n    // Process Public FX results\n    if (publicFxResult.status === \"fulfilled\" && publicFxResult.value.success) {\n        Object.assign(allRates, publicFxResult.value.rates);\n        providerNotes.push(\"PublicFX: \".concat(Object.keys(publicFxResult.value.rates).length, \" rates\"));\n    } else {\n        var _publicFxResult_reason, _publicFxResult_value;\n        const error = publicFxResult.status === \"rejected\" ? (_publicFxResult_reason = publicFxResult.reason) === null || _publicFxResult_reason === void 0 ? void 0 : _publicFxResult_reason.message : (_publicFxResult_value = publicFxResult.value) === null || _publicFxResult_value === void 0 ? void 0 : _publicFxResult_value.error;\n        providerNotes.push(\"PublicFX: Failed (\".concat(error, \")\"));\n    }\n    // Add inverse rates for all direct rates\n    const directRates = {\n        ...allRates\n    };\n    for (const [key, rate] of Object.entries(directRates)){\n        const inverseKey = createRateKey(rate.quote, rate.base);\n        if (!allRates[inverseKey]) {\n            allRates[inverseKey] = getInverseRate(rate);\n        }\n    }\n    // Add fallback rates if we have very few rates\n    if (Object.keys(allRates).length < 4) {\n        providerNotes.push(\"Using fallback rates due to limited data\");\n        // Add some reasonable fallback rates for testing\n        if (!allRates[\"USD-VES\"]) {\n            allRates[\"USD-VES\"] = {\n                base: \"USD\",\n                quote: \"VES\",\n                value: 195.0,\n                provider: \"Fallback\",\n                at: new Date().toISOString()\n            };\n            allRates[\"VES-USD\"] = getInverseRate(allRates[\"USD-VES\"]);\n        }\n        if (!allRates[\"USD-COP\"]) {\n            allRates[\"USD-COP\"] = {\n                base: \"USD\",\n                quote: \"COP\",\n                value: 4100,\n                provider: \"Fallback\",\n                at: new Date().toISOString()\n            };\n            allRates[\"COP-USD\"] = getInverseRate(allRates[\"USD-COP\"]);\n        }\n    }\n    // Compute cross rates for missing pairs\n    const requiredPairs = [\n        \"COP-VES\",\n        \"VES-COP\"\n    ];\n    for (const pair of requiredPairs){\n        if (!allRates[pair]) {\n            const [base, quote] = pair.split(\"-\");\n            // Try COP-VES via COP-USD and USD-VES\n            if (base === \"COP\" && quote === \"VES\") {\n                const copUsd = allRates[\"COP-USD\"];\n                const usdVes = allRates[\"USD-VES\"];\n                if (copUsd && usdVes) {\n                    const crossRate = computeCrossRate(copUsd, usdVes, \"COP\", \"VES\");\n                    if (crossRate) {\n                        allRates[\"COP-VES\"] = crossRate;\n                        allRates[\"VES-COP\"] = getInverseRate(crossRate);\n                        providerNotes.push(\"COP-VES: Computed via COP-USD \\xd7 USD-VES\");\n                    }\n                }\n            }\n        }\n    }\n    return allRates;\n}\nfunction convert(amount, from, to, rates) {\n    if (from === to) return amount;\n    const directKey = createRateKey(from, to);\n    const directRate = rates[directKey];\n    if (directRate) {\n        return roundToSignificantDigits(amount * directRate.value, 8);\n    }\n    // Try cross conversion via USD (most reliable base currency)\n    const fromUsdKey = createRateKey(from, \"USD\");\n    const usdToKey = createRateKey(\"USD\", to);\n    if (rates[fromUsdKey] && rates[usdToKey]) {\n        const viaUsd = amount * rates[fromUsdKey].value * rates[usdToKey].value;\n        return roundToSignificantDigits(viaUsd, 8);\n    }\n    // Try cross conversion via EUR\n    const fromEurKey = createRateKey(from, \"EUR\");\n    const eurToKey = createRateKey(\"EUR\", to);\n    if (rates[fromEurKey] && rates[eurToKey]) {\n        const viaEur = amount * rates[fromEurKey].value * rates[eurToKey].value;\n        return roundToSignificantDigits(viaEur, 8);\n    }\n    // Try cross conversion via COP (for VES-COP specifically)\n    if (from === \"VES\" && to === \"COP\") {\n        const vesUsdKey = createRateKey(\"VES\", \"USD\");\n        const usdCopKey = createRateKey(\"USD\", \"COP\");\n        if (rates[vesUsdKey] && rates[usdCopKey]) {\n            const viaUsd = amount * rates[vesUsdKey].value * rates[usdCopKey].value;\n            return roundToSignificantDigits(viaUsd, 8);\n        }\n    }\n    if (from === \"COP\" && to === \"VES\") {\n        const copUsdKey = createRateKey(\"COP\", \"USD\");\n        const usdVesKey = createRateKey(\"USD\", \"VES\");\n        if (rates[copUsdKey] && rates[usdVesKey]) {\n            const viaUsd = amount * rates[copUsdKey].value * rates[usdVesKey].value;\n            return roundToSignificantDigits(viaUsd, 8);\n        }\n    }\n    // Try multi-hop conversion: VES -> USD -> EUR -> Target\n    if (from === \"VES\" && (to === \"EUR\" || to === \"COP\")) {\n        const vesUsdKey = createRateKey(\"VES\", \"USD\");\n        const usdEurKey = createRateKey(\"USD\", \"EUR\");\n        const eurTargetKey = createRateKey(\"EUR\", to);\n        if (rates[vesUsdKey] && rates[usdEurKey] && rates[eurTargetKey]) {\n            const viaUsdEur = amount * rates[vesUsdKey].value * rates[usdEurKey].value * rates[eurTargetKey].value;\n            return roundToSignificantDigits(viaUsdEur, 8);\n        }\n    }\n    return null;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcmF0ZXMvY29tcG9zZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQzZDO0FBQ2dCO0FBQ047QUFDWTtBQUU1RCxTQUFTSSxjQUFjQyxJQUFjLEVBQUVDLEtBQWU7SUFDM0QsT0FBTyxHQUFXQSxPQUFSRCxNQUFLLEtBQVMsT0FBTkM7QUFDcEI7QUFFTyxTQUFTQyxlQUFlQyxJQUFVO0lBQ3ZDLE9BQU87UUFDTEgsTUFBTUcsS0FBS0YsS0FBSztRQUNoQkEsT0FBT0UsS0FBS0gsSUFBSTtRQUNoQkksT0FBTyxJQUFJRCxLQUFLQyxLQUFLO1FBQ3JCQyxVQUFVRixLQUFLRSxRQUFRO1FBQ3ZCQyxJQUFJSCxLQUFLRyxFQUFFO0lBQ2I7QUFDRjtBQUVPLFNBQVNDLHlCQUF5QkgsS0FBYTtRQUFFSSxTQUFBQSxpRUFBaUI7SUFDdkUsSUFBSUosVUFBVSxHQUFHLE9BQU87SUFDeEIsTUFBTUssWUFBWUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxLQUFLLENBQUNGLEtBQUtHLEdBQUcsQ0FBQ1Q7SUFDakQsTUFBTVUsU0FBU0osS0FBS0ssR0FBRyxDQUFDLElBQUlQLFNBQVMsSUFBSUM7SUFDekMsT0FBT0MsS0FBS00sS0FBSyxDQUFDWixRQUFRVSxVQUFVQTtBQUN0QztBQUVPLFNBQVNHLGlCQUNkQyxLQUFXLEVBQ1hDLEtBQVcsRUFDWEMsVUFBb0IsRUFDcEJDLFdBQXFCO0lBRXJCLHlDQUF5QztJQUN6QyxJQUFJSCxNQUFNakIsS0FBSyxLQUFLa0IsTUFBTW5CLElBQUksRUFBRTtRQUM5QixPQUFPO0lBQ1Q7SUFFQSxNQUFNc0IsYUFBYUosTUFBTWQsS0FBSyxHQUFHZSxNQUFNZixLQUFLO0lBQzVDLE1BQU1tQixlQUFlaEIseUJBQXlCZTtJQUU5QyxPQUFPO1FBQ0x0QixNQUFNb0I7UUFDTm5CLE9BQU9vQjtRQUNQakIsT0FBT21CO1FBQ1BsQixVQUFVLEdBQXFCYyxPQUFsQkQsTUFBTWIsUUFBUSxF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Q3BFLEtBQUssR0FBR21DLEtBQUssQ0FBQ2tDLGFBQWEsQ0FBQ3JFLEtBQUs7WUFDdEcsT0FBT0cseUJBQXlCbUUsV0FBVztRQUM3QztJQUNGO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvcmF0ZXMvY29tcG9zZS50cz80Yzk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEN1cnJlbmN5LCBSYXRlLCBSYXRlc0J1bmRsZSB9IGZyb20gJy4vdHlwZXMnXHJcbmltcG9ydCB7IGdldEJDVlJhdGVzIH0gZnJvbSAnLi9wcm92aWRlcnMvYmN2J1xyXG5pbXBvcnQgeyBnZXRGcmFua2Z1cnRlclJhdGVzIH0gZnJvbSAnLi9wcm92aWRlcnMvZnJhbmtmdXJ0ZXInXHJcbmltcG9ydCB7IGdldFB1YmxpY0Z4UmF0ZXMgfSBmcm9tICcuL3Byb3ZpZGVycy9wdWJsaWNGeCdcclxuaW1wb3J0IHsgZ2V0QWx0ZXJuYXRpdmVWRVNSYXRlcyB9IGZyb20gJy4vcHJvdmlkZXJzL2FsdGVybmF0aXZlVmVzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhdGVLZXkoYmFzZTogQ3VycmVuY3ksIHF1b3RlOiBDdXJyZW5jeSk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGAke2Jhc2V9LSR7cXVvdGV9YFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW52ZXJzZVJhdGUocmF0ZTogUmF0ZSk6IFJhdGUge1xyXG4gIHJldHVybiB7XHJcbiAgICBiYXNlOiByYXRlLnF1b3RlLFxyXG4gICAgcXVvdGU6IHJhdGUuYmFzZSxcclxuICAgIHZhbHVlOiAxIC8gcmF0ZS52YWx1ZSxcclxuICAgIHByb3ZpZGVyOiByYXRlLnByb3ZpZGVyLFxyXG4gICAgYXQ6IHJhdGUuYXRcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvU2lnbmlmaWNhbnREaWdpdHModmFsdWU6IG51bWJlciwgZGlnaXRzOiBudW1iZXIgPSA2KTogbnVtYmVyIHtcclxuICBpZiAodmFsdWUgPT09IDApIHJldHVybiAwXHJcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE1hdGguYWJzKHZhbHVlKSkpXHJcbiAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coMTAsIGRpZ2l0cyAtIDEgLSBtYWduaXR1ZGUpXHJcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBmYWN0b3IpIC8gZmFjdG9yXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQ3Jvc3NSYXRlKFxyXG4gIHJhdGUxOiBSYXRlLFxyXG4gIHJhdGUyOiBSYXRlLFxyXG4gIHRhcmdldEJhc2U6IEN1cnJlbmN5LFxyXG4gIHRhcmdldFF1b3RlOiBDdXJyZW5jeVxyXG4pOiBSYXRlIHwgbnVsbCB7XHJcbiAgLy8gQ2hlY2sgaWYgd2UgY2FuIGNvbXB1dGUgdGhlIGNyb3NzIHJhdGVcclxuICBpZiAocmF0ZTEucXVvdGUgIT09IHJhdGUyLmJhc2UpIHtcclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IGNyb3NzVmFsdWUgPSByYXRlMS52YWx1ZSAqIHJhdGUyLnZhbHVlXHJcbiAgY29uc3Qgcm91bmRlZFZhbHVlID0gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKGNyb3NzVmFsdWUpXHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGJhc2U6IHRhcmdldEJhc2UsXHJcbiAgICBxdW90ZTogdGFyZ2V0UXVvdGUsXHJcbiAgICB2YWx1ZTogcm91bmRlZFZhbHVlLFxyXG4gICAgcHJvdmlkZXI6IGAke3JhdGUxLnByb3ZpZGVyfSske3JhdGUyLnByb3ZpZGVyfWAsXHJcbiAgICBhdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcG9zZVJhdGVzKCk6IFByb21pc2U8UmF0ZXNCdW5kbGU+IHtcclxuICBjb25zdCBhbGxSYXRlczogUmF0ZXNCdW5kbGUgPSB7fVxyXG4gIGNvbnN0IHByb3ZpZGVyTm90ZXM6IHN0cmluZ1tdID0gW11cclxuICBcclxuICAvLyBGZXRjaCBmcm9tIGFsbCBwcm92aWRlcnMgaW4gcGFyYWxsZWxcclxuICBjb25zdCBbYmN2UmVzdWx0LCBmcmFua2Z1cnRlclJlc3VsdCwgcHVibGljRnhSZXN1bHQsIGFsdGVybmF0aXZlVmVzUmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbXHJcbiAgICBnZXRCQ1ZSYXRlcygpLFxyXG4gICAgZ2V0RnJhbmtmdXJ0ZXJSYXRlcygpLFxyXG4gICAgZ2V0UHVibGljRnhSYXRlcygpLFxyXG4gICAgZ2V0QWx0ZXJuYXRpdmVWRVNSYXRlcygpXHJcbiAgXSlcclxuICBcclxuICAvLyBQcm9jZXNzIEJDViByZXN1bHRzXHJcbiAgaWYgKGJjdlJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnICYmIGJjdlJlc3VsdC52YWx1ZS5zdWNjZXNzKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKGFsbFJhdGVzLCBiY3ZSZXN1bHQudmFsdWUucmF0ZXMpXHJcbiAgICBwcm92aWRlck5vdGVzLnB1c2goYEJDVjogJHtPYmplY3Qua2V5cyhiY3ZSZXN1bHQudmFsdWUucmF0ZXMpLmxlbmd0aH0gcmF0ZXNgKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBlcnJvciA9IGJjdlJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcgPyBiY3ZSZXN1bHQucmVhc29uPy5tZXNzYWdlIDogYmN2UmVzdWx0LnZhbHVlPy5lcnJvclxyXG4gICAgcHJvdmlkZXJOb3Rlcy5wdXNoKGBCQ1Y6IEZhaWxlZCAoJHtlcnJvcn0pYClcclxuICB9XHJcbiAgXHJcbiAgLy8gUHJvY2VzcyBGcmFua2Z1cnRlciByZXN1bHRzXHJcbiAgaWYgKGZyYW5rZnVydGVyUmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgZnJhbmtmdXJ0ZXJSZXN1bHQudmFsdWUuc3VjY2Vzcykge1xyXG4gICAgT2JqZWN0LmFzc2lnbihhbGxSYXRlcywgZnJhbmtmdXJ0ZXJSZXN1bHQudmFsdWUucmF0ZXMpXHJcbiAgICBwcm92aWRlck5vdGVzLnB1c2goYEZyYW5rZnVydGVyOiAke09iamVjdC5rZXlzKGZyYW5rZnVydGVyUmVzdWx0LnZhbHVlLnJhdGVzKS5sZW5ndGh9IHJhdGVzYClcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgZXJyb3IgPSBmcmFua2Z1cnRlclJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcgPyBmcmFua2Z1cnRlclJlc3VsdC5yZWFzb24/Lm1lc3NhZ2UgOiBmcmFua2Z1cnRlclJlc3VsdC52YWx1ZT8uZXJyb3JcclxuICAgIHByb3ZpZGVyTm90ZXMucHVzaChgRnJhbmtmdXJ0ZXI6IEZhaWxlZCAoJHtlcnJvcn0pYClcclxuICB9XHJcbiAgXHJcbiAgLy8gUHJvY2VzcyBQdWJsaWMgRlggcmVzdWx0c1xyXG4gIGlmIChwdWJsaWNGeFJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnICYmIHB1YmxpY0Z4UmVzdWx0LnZhbHVlLnN1Y2Nlc3MpIHtcclxuICAgIE9iamVjdC5hc3NpZ24oYWxsUmF0ZXMsIHB1YmxpY0Z4UmVzdWx0LnZhbHVlLnJhdGVzKVxyXG4gICAgcHJvdmlkZXJOb3Rlcy5wdXNoKGBQdWJsaWNGWDogJHtPYmplY3Qua2V5cyhwdWJsaWNGeFJlc3VsdC52YWx1ZS5yYXRlcykubGVuZ3RofSByYXRlc2ApXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGVycm9yID0gcHVibGljRnhSZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnID8gcHVibGljRnhSZXN1bHQucmVhc29uPy5tZXNzYWdlIDogcHVibGljRnhSZXN1bHQudmFsdWU/LmVycm9yXHJcbiAgICBwcm92aWRlck5vdGVzLnB1c2goYFB1YmxpY0ZYOiBGYWlsZWQgKCR7ZXJyb3J9KWApXHJcbiAgfVxyXG4gIFxyXG4gIC8vIEFkZCBpbnZlcnNlIHJhdGVzIGZvciBhbGwgZGlyZWN0IHJhdGVzXHJcbiAgY29uc3QgZGlyZWN0UmF0ZXMgPSB7IC4uLmFsbFJhdGVzIH1cclxuICBmb3IgKGNvbnN0IFtrZXksIHJhdGVdIG9mIE9iamVjdC5lbnRyaWVzKGRpcmVjdFJhdGVzKSkge1xyXG4gICAgY29uc3QgaW52ZXJzZUtleSA9IGNyZWF0ZVJhdGVLZXkocmF0ZS5xdW90ZSwgcmF0ZS5iYXNlKVxyXG4gICAgaWYgKCFhbGxSYXRlc1tpbnZlcnNlS2V5XSkge1xyXG4gICAgICBhbGxSYXRlc1tpbnZlcnNlS2V5XSA9IGdldEludmVyc2VSYXRlKHJhdGUpXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEFkZCBmYWxsYmFjayByYXRlcyBpZiB3ZSBoYXZlIHZlcnkgZmV3IHJhdGVzXHJcbiAgaWYgKE9iamVjdC5rZXlzKGFsbFJhdGVzKS5sZW5ndGggPCA0KSB7XHJcbiAgICBwcm92aWRlck5vdGVzLnB1c2goJ1VzaW5nIGZhbGxiYWNrIHJhdGVzIGR1ZSB0byBsaW1pdGVkIGRhdGEnKVxyXG4gICAgXHJcbiAgICAvLyBBZGQgc29tZSByZWFzb25hYmxlIGZhbGxiYWNrIHJhdGVzIGZvciB0ZXN0aW5nXHJcbiAgICBpZiAoIWFsbFJhdGVzWydVU0QtVkVTJ10pIHtcclxuICAgICAgYWxsUmF0ZXNbJ1VTRC1WRVMnXSA9IHtcclxuICAgICAgICBiYXNlOiAnVVNEJyxcclxuICAgICAgICBxdW90ZTogJ1ZFUycsXHJcbiAgICAgICAgdmFsdWU6IDE5NS4wLCAvLyBVcGRhdGVkIGFwcHJveGltYXRlIHJhdGUgKE9jdG9iZXIgMjAyNClcclxuICAgICAgICBwcm92aWRlcjogJ0ZhbGxiYWNrJyxcclxuICAgICAgICBhdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH1cclxuICAgICAgYWxsUmF0ZXNbJ1ZFUy1VU0QnXSA9IGdldEludmVyc2VSYXRlKGFsbFJhdGVzWydVU0QtVkVTJ10pXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghYWxsUmF0ZXNbJ1VTRC1DT1AnXSkge1xyXG4gICAgICBhbGxSYXRlc1snVVNELUNPUCddID0ge1xyXG4gICAgICAgIGJhc2U6ICdVU0QnLFxyXG4gICAgICAgIHF1b3RlOiAnQ09QJyxcclxuICAgICAgICB2YWx1ZTogNDEwMCwgLy8gQXBwcm94aW1hdGUgcmF0ZVxyXG4gICAgICAgIHByb3ZpZGVyOiAnRmFsbGJhY2snLFxyXG4gICAgICAgIGF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfVxyXG4gICAgICBhbGxSYXRlc1snQ09QLVVTRCddID0gZ2V0SW52ZXJzZVJhdGUoYWxsUmF0ZXNbJ1VTRC1DT1AnXSlcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gQ29tcHV0ZSBjcm9zcyByYXRlcyBmb3IgbWlzc2luZyBwYWlyc1xyXG4gIGNvbnN0IHJlcXVpcmVkUGFpcnMgPSBbXHJcbiAgICAnQ09QLVZFUycsICdWRVMtQ09QJ1xyXG4gIF1cclxuICBcclxuICBmb3IgKGNvbnN0IHBhaXIgb2YgcmVxdWlyZWRQYWlycykge1xyXG4gICAgaWYgKCFhbGxSYXRlc1twYWlyXSkge1xyXG4gICAgICBjb25zdCBbYmFzZSwgcXVvdGVdID0gcGFpci5zcGxpdCgnLScpIGFzIFtDdXJyZW5jeSwgQ3VycmVuY3ldXHJcbiAgICAgIFxyXG4gICAgICAvLyBUcnkgQ09QLVZFUyB2aWEgQ09QLVVTRCBhbmQgVVNELVZFU1xyXG4gICAgICBpZiAoYmFzZSA9PT0gJ0NPUCcgJiYgcXVvdGUgPT09ICdWRVMnKSB7XHJcbiAgICAgICAgY29uc3QgY29wVXNkID0gYWxsUmF0ZXNbJ0NPUC1VU0QnXVxyXG4gICAgICAgIGNvbnN0IHVzZFZlcyA9IGFsbFJhdGVzWydVU0QtVkVTJ11cclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29wVXNkICYmIHVzZFZlcykge1xyXG4gICAgICAgICAgY29uc3QgY3Jvc3NSYXRlID0gY29tcHV0ZUNyb3NzUmF0ZShjb3BVc2QsIHVzZFZlcywgJ0NPUCcsICdWRVMnKVxyXG4gICAgICAgICAgaWYgKGNyb3NzUmF0ZSkge1xyXG4gICAgICAgICAgICBhbGxSYXRlc1snQ09QLVZFUyddID0gY3Jvc3NSYXRlXHJcbiAgICAgICAgICAgIGFsbFJhdGVzWydWRVMtQ09QJ10gPSBnZXRJbnZlcnNlUmF0ZShjcm9zc1JhdGUpXHJcbiAgICAgICAgICAgIHByb3ZpZGVyTm90ZXMucHVzaCgnQ09QLVZFUzogQ29tcHV0ZWQgdmlhIENPUC1VU0Qgw5cgVVNELVZFUycpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBhbGxSYXRlc1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydChcclxuICBhbW91bnQ6IG51bWJlcixcclxuICBmcm9tOiBDdXJyZW5jeSxcclxuICB0bzogQ3VycmVuY3ksXHJcbiAgcmF0ZXM6IFJhdGVzQnVuZGxlXHJcbik6IG51bWJlciB8IG51bGwge1xyXG4gIGlmIChmcm9tID09PSB0bykgcmV0dXJuIGFtb3VudFxyXG4gIFxyXG4gIGNvbnN0IGRpcmVjdEtleSA9IGNyZWF0ZVJhdGVLZXkoZnJvbSwgdG8pXHJcbiAgY29uc3QgZGlyZWN0UmF0ZSA9IHJhdGVzW2RpcmVjdEtleV1cclxuICBcclxuICBpZiAoZGlyZWN0UmF0ZSkge1xyXG4gICAgcmV0dXJuIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyhhbW91bnQgKiBkaXJlY3RSYXRlLnZhbHVlLCA4KVxyXG4gIH1cclxuICBcclxuICAvLyBUcnkgY3Jvc3MgY29udmVyc2lvbiB2aWEgVVNEIChtb3N0IHJlbGlhYmxlIGJhc2UgY3VycmVuY3kpXHJcbiAgY29uc3QgZnJvbVVzZEtleSA9IGNyZWF0ZVJhdGVLZXkoZnJvbSwgJ1VTRCcpXHJcbiAgY29uc3QgdXNkVG9LZXkgPSBjcmVhdGVSYXRlS2V5KCdVU0QnLCB0bylcclxuICBcclxuICBpZiAocmF0ZXNbZnJvbVVzZEtleV0gJiYgcmF0ZXNbdXNkVG9LZXldKSB7XHJcbiAgICBjb25zdCB2aWFVc2QgPSBhbW91bnQgKiByYXRlc1tmcm9tVXNkS2V5XS52YWx1ZSAqIHJhdGVzW3VzZFRvS2V5XS52YWx1ZVxyXG4gICAgcmV0dXJuIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyh2aWFVc2QsIDgpXHJcbiAgfVxyXG4gIFxyXG4gIC8vIFRyeSBjcm9zcyBjb252ZXJzaW9uIHZpYSBFVVJcclxuICBjb25zdCBmcm9tRXVyS2V5ID0gY3JlYXRlUmF0ZUtleShmcm9tLCAnRVVSJylcclxuICBjb25zdCBldXJUb0tleSA9IGNyZWF0ZVJhdGVLZXkoJ0VVUicsIHRvKVxyXG4gIFxyXG4gIGlmIChyYXRlc1tmcm9tRXVyS2V5XSAmJiByYXRlc1tldXJUb0tleV0pIHtcclxuICAgIGNvbnN0IHZpYUV1ciA9IGFtb3VudCAqIHJhdGVzW2Zyb21FdXJLZXldLnZhbHVlICogcmF0ZXNbZXVyVG9LZXldLnZhbHVlXHJcbiAgICByZXR1cm4gcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZpYUV1ciwgOClcclxuICB9XHJcbiAgXHJcbiAgLy8gVHJ5IGNyb3NzIGNvbnZlcnNpb24gdmlhIENPUCAoZm9yIFZFUy1DT1Agc3BlY2lmaWNhbGx5KVxyXG4gIGlmIChmcm9tID09PSAnVkVTJyAmJiB0byA9PT0gJ0NPUCcpIHtcclxuICAgIGNvbnN0IHZlc1VzZEtleSA9IGNyZWF0ZVJhdGVLZXkoJ1ZFUycsICdVU0QnKVxyXG4gICAgY29uc3QgdXNkQ29wS2V5ID0gY3JlYXRlUmF0ZUtleSgnVVNEJywgJ0NPUCcpXHJcbiAgICBcclxuICAgIGlmIChyYXRlc1t2ZXNVc2RLZXldICYmIHJhdGVzW3VzZENvcEtleV0pIHtcclxuICAgICAgY29uc3QgdmlhVXNkID0gYW1vdW50ICogcmF0ZXNbdmVzVXNkS2V5XS52YWx1ZSAqIHJhdGVzW3VzZENvcEtleV0udmFsdWVcclxuICAgICAgcmV0dXJuIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyh2aWFVc2QsIDgpXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChmcm9tID09PSAnQ09QJyAmJiB0byA9PT0gJ1ZFUycpIHtcclxuICAgIGNvbnN0IGNvcFVzZEtleSA9IGNyZWF0ZVJhdGVLZXkoJ0NPUCcsICdVU0QnKVxyXG4gICAgY29uc3QgdXNkVmVzS2V5ID0gY3JlYXRlUmF0ZUtleSgnVVNEJywgJ1ZFUycpXHJcbiAgICBcclxuICAgIGlmIChyYXRlc1tjb3BVc2RLZXldICYmIHJhdGVzW3VzZFZlc0tleV0pIHtcclxuICAgICAgY29uc3QgdmlhVXNkID0gYW1vdW50ICogcmF0ZXNbY29wVXNkS2V5XS52YWx1ZSAqIHJhdGVzW3VzZFZlc0tleV0udmFsdWVcclxuICAgICAgcmV0dXJuIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyh2aWFVc2QsIDgpXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFRyeSBtdWx0aS1ob3AgY29udmVyc2lvbjogVkVTIC0+IFVTRCAtPiBFVVIgLT4gVGFyZ2V0XHJcbiAgaWYgKGZyb20gPT09ICdWRVMnICYmICh0byA9PT0gJ0VVUicgfHwgdG8gPT09ICdDT1AnKSkge1xyXG4gICAgY29uc3QgdmVzVXNkS2V5ID0gY3JlYXRlUmF0ZUtleSgnVkVTJywgJ1VTRCcpXHJcbiAgICBjb25zdCB1c2RFdXJLZXkgPSBjcmVhdGVSYXRlS2V5KCdVU0QnLCAnRVVSJylcclxuICAgIGNvbnN0IGV1clRhcmdldEtleSA9IGNyZWF0ZVJhdGVLZXkoJ0VVUicsIHRvKVxyXG4gICAgXHJcbiAgICBpZiAocmF0ZXNbdmVzVXNkS2V5XSAmJiByYXRlc1t1c2RFdXJLZXldICYmIHJhdGVzW2V1clRhcmdldEtleV0pIHtcclxuICAgICAgY29uc3QgdmlhVXNkRXVyID0gYW1vdW50ICogcmF0ZXNbdmVzVXNkS2V5XS52YWx1ZSAqIHJhdGVzW3VzZEV1cktleV0udmFsdWUgKiByYXRlc1tldXJUYXJnZXRLZXldLnZhbHVlXHJcbiAgICAgIHJldHVybiByb3VuZFRvU2lnbmlmaWNhbnREaWdpdHModmlhVXNkRXVyLCA4KVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gbnVsbFxyXG59XHJcbiJdLCJuYW1lcyI6WyJnZXRCQ1ZSYXRlcyIsImdldEZyYW5rZnVydGVyUmF0ZXMiLCJnZXRQdWJsaWNGeFJhdGVzIiwiZ2V0QWx0ZXJuYXRpdmVWRVNSYXRlcyIsImNyZWF0ZVJhdGVLZXkiLCJiYXNlIiwicXVvdGUiLCJnZXRJbnZlcnNlUmF0ZSIsInJhdGUiLCJ2YWx1ZSIsInByb3ZpZGVyIiwiYXQiLCJyb3VuZFRvU2lnbmlmaWNhbnREaWdpdHMiLCJkaWdpdHMiLCJtYWduaXR1ZGUiLCJNYXRoIiwiZmxvb3IiLCJsb2cxMCIsImFicyIsImZhY3RvciIsInBvdyIsInJvdW5kIiwiY29tcHV0ZUNyb3NzUmF0ZSIsInJhdGUxIiwicmF0ZTIiLCJ0YXJnZXRCYXNlIiwidGFyZ2V0UXVvdGUiLCJjcm9zc1ZhbHVlIiwicm91bmRlZFZhbHVlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29tcG9zZVJhdGVzIiwiYWxsUmF0ZXMiLCJwcm92aWRlck5vdGVzIiwiYmN2UmVzdWx0IiwiZnJhbmtmdXJ0ZXJSZXN1bHQiLCJwdWJsaWNGeFJlc3VsdCIsImFsdGVybmF0aXZlVmVzUmVzdWx0IiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJzdGF0dXMiLCJzdWNjZXNzIiwiT2JqZWN0IiwiYXNzaWduIiwicmF0ZXMiLCJwdXNoIiwia2V5cyIsImxlbmd0aCIsImVycm9yIiwicmVhc29uIiwibWVzc2FnZSIsImRpcmVjdFJhdGVzIiwia2V5IiwiZW50cmllcyIsImludmVyc2VLZXkiLCJyZXF1aXJlZFBhaXJzIiwicGFpciIsInNwbGl0IiwiY29wVXNkIiwidXNkVmVzIiwiY3Jvc3NSYXRlIiwiY29udmVydCIsImFtb3VudCIsImZyb20iLCJ0byIsImRpcmVjdEtleSIsImRpcmVjdFJhdGUiLCJmcm9tVXNkS2V5IiwidXNkVG9LZXkiLCJ2aWFVc2QiLCJmcm9tRXVyS2V5IiwiZXVyVG9LZXkiLCJ2aWFFdXIiLCJ2ZXNVc2RLZXkiLCJ1c2RDb3BLZXkiLCJjb3BVc2RLZXkiLCJ1c2RWZXNLZXkiLCJ1c2RFdXJLZXkiLCJldXJUYXJnZXRLZXkiLCJ2aWFVc2RFdXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/rates/compose.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/rates/providers/alternativeVes.ts":
/*!***************************************************!*\
  !*** ./src/lib/rates/providers/alternativeVes.ts ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAlternativeVESRates: function() { return /* binding */ getAlternativeVESRates; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_@babel+core@7.2_4dd0d9bf506f07f172b83f2c542efdce/node_modules/next/dist/build/polyfills/process.js\");\n// Alternative sources for VES rates that might work better\nconst ALTERNATIVE_VES_SOURCES = [\n    {\n        name: \"XE.com\",\n        url: \"https://www.xe.com/currencyconverter/convert/?Amount=1&From=USD&To=VES\",\n        parseHtml: true\n    },\n    {\n        name: \"Wise.com\",\n        url: \"https://wise.com/us/currency-converter/usd-to-ves-rate\",\n        parseHtml: true\n    },\n    {\n        name: \"CurrencyAPI\",\n        url: \"https://api.currencyapi.com/v3/latest?base_currency=USD&currencies=VES\",\n        parseHtml: false\n    }\n];\nasync function fetchWithRetry(url) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    for(let i = 0; i < retries; i++){\n        try {\n            const response = await fetch(url, {\n                ...options,\n                headers: {\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n                    \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                    \"Accept-Language\": \"en-US,en;q=0.5\",\n                    \"Accept-Encoding\": \"gzip, deflate, br\",\n                    \"Connection\": \"keep-alive\",\n                    \"Upgrade-Insecure-Requests\": \"1\",\n                    ...options.headers\n                }\n            });\n            if (response.ok) {\n                return response;\n            }\n        } catch (error) {\n            console.warn(\"Attempt \".concat(i + 1, \" failed for \").concat(url, \":\"), error);\n            if (i === retries - 1) throw error;\n            await new Promise((resolve)=>setTimeout(resolve, 1000 * (i + 1)));\n        }\n    }\n    throw new Error(\"All retry attempts failed\");\n}\nfunction parseVESFromHTML(html, source) {\n    const rates = {};\n    // Multiple patterns to try for USD/VES\n    const usdPatterns = [\n        // XE.com patterns\n        /1\\s*USD\\s*=\\s*([\\d,\\.]+)\\s*VES/i,\n        /USD\\s*to\\s*VES[^>]*>([\\d,\\.]+)</i,\n        // Wise.com patterns\n        /1\\s*US\\s*dollar\\s*=\\s*([\\d,\\.]+)\\s*VES/i,\n        /USD\\s*to\\s*VES[^>]*>([\\d,\\.]+)</i,\n        // Generic patterns\n        /USD\\s*=\\s*([\\d,\\.]+)\\s*VES/i,\n        /1\\s*USD\\s*=\\s*([\\d,\\.]+)\\s*Bolívar/i,\n        /Dólar\\s*=\\s*([\\d,\\.]+)\\s*Bolívar/i\n    ];\n    for (const pattern of usdPatterns){\n        const match = html.match(pattern);\n        if (match) {\n            const rate = parseFloat(match[1].replace(/,/g, \"\"));\n            if (!isNaN(rate) && rate > 50 && rate < 1000) {\n                rates[\"USD-VES\"] = {\n                    base: \"USD\",\n                    quote: \"VES\",\n                    value: rate,\n                    provider: source,\n                    at: new Date().toISOString()\n                };\n                break;\n            }\n        }\n    }\n    return rates;\n}\nfunction parseVESFromJSON(data, source) {\n    const rates = {};\n    try {\n        let usdVesRate = null;\n        if (source === \"CurrencyAPI\") {\n            var _data_data_VES, _data_data;\n            if ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : (_data_data_VES = _data_data.VES) === null || _data_data_VES === void 0 ? void 0 : _data_data_VES.value) {\n                usdVesRate = data.data.VES.value;\n            }\n        }\n        if (usdVesRate && usdVesRate > 50 && usdVesRate < 1000) {\n            var _data_meta;\n            rates[\"USD-VES\"] = {\n                base: \"USD\",\n                quote: \"VES\",\n                value: usdVesRate,\n                provider: source,\n                at: ((_data_meta = data.meta) === null || _data_meta === void 0 ? void 0 : _data_meta.last_updated_at) || new Date().toISOString()\n            };\n        }\n    } catch (error) {\n        console.warn(\"Failed to parse \".concat(source, \" JSON response:\"), error);\n    }\n    return rates;\n}\nasync function getAlternativeVESRates() {\n    const allRates = [];\n    const errors = [];\n    const apiKey = process.env.PUBLIC_FX_API_KEY;\n    // Try multiple sources in parallel\n    const sourcePromises = ALTERNATIVE_VES_SOURCES.map(async (source)=>{\n        // Skip sources that require API key if we don't have one\n        if (source.name === \"CurrencyAPI\" && !apiKey) {\n            return {\n                source: source.name,\n                rates: [],\n                success: false,\n                error: \"API key required but not provided\"\n            };\n        }\n        try {\n            let url = source.url;\n            // Add API key to URL if required\n            if (source.name === \"CurrencyAPI\" && apiKey) {\n                url = \"\".concat(source.url, \"&apikey=\").concat(apiKey);\n            }\n            const response = await fetchWithRetry(url, {\n                next: {\n                    revalidate: 3600\n                }\n            });\n            if (source.parseHtml) {\n                const html = await response.text();\n                const rates = parseVESFromHTML(html, source.name);\n                return {\n                    source: source.name,\n                    rates: Object.values(rates),\n                    success: Object.keys(rates).length > 0\n                };\n            } else {\n                const data = await response.json();\n                const rates = parseVESFromJSON(data, source.name);\n                return {\n                    source: source.name,\n                    rates: Object.values(rates),\n                    success: Object.keys(rates).length > 0\n                };\n            }\n        } catch (error) {\n            console.warn(\"\".concat(source.name, \" failed:\"), error);\n            return {\n                source: source.name,\n                rates: [],\n                success: false,\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    });\n    const results = await Promise.allSettled(sourcePromises);\n    // Collect all successful rates\n    results.forEach((result)=>{\n        if (result.status === \"fulfilled\" && result.value.success) {\n            allRates.push(...result.value.rates);\n        } else if (result.status === \"rejected\") {\n            var _result_reason;\n            errors.push(((_result_reason = result.reason) === null || _result_reason === void 0 ? void 0 : _result_reason.message) || \"Unknown error\");\n        }\n    });\n    if (allRates.length === 0) {\n        return {\n            rates: {},\n            provider: \"Alternative-VES\",\n            success: false,\n            error: \"All sources failed: \".concat(errors.join(\", \"))\n        };\n    }\n    // Average rates from multiple sources\n    const averagedRates = {};\n    const usdVesRates = allRates.filter((r)=>r.base === \"USD\" && r.quote === \"VES\");\n    if (usdVesRates.length > 0) {\n        const avgUsdVes = usdVesRates.reduce((sum, r)=>sum + r.value, 0) / usdVesRates.length;\n        averagedRates[\"USD-VES\"] = {\n            base: \"USD\",\n            quote: \"VES\",\n            value: avgUsdVes,\n            provider: \"Average of \".concat(usdVesRates.length, \" sources\"),\n            at: new Date().toISOString()\n        };\n    }\n    return {\n        rates: averagedRates,\n        provider: \"Alternative-VES\",\n        success: true\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcmF0ZXMvcHJvdmlkZXJzL2FsdGVybmF0aXZlVmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRUEsMkRBQTJEO0FBQzNELE1BQU1BLDBCQUEwQjtJQUM5QjtRQUNFQyxNQUFNO1FBQ05DLEtBQUs7UUFDTEMsV0FBVztJQUNiO0lBQ0E7UUFDRUYsTUFBTTtRQUNOQyxLQUFLO1FBQ0xDLFdBQVc7SUFDYjtJQUNBO1FBQ0VGLE1BQU07UUFDTkMsS0FBSztRQUNMQyxXQUFXO0lBQ2I7Q0FDRDtBQUVELGVBQWVDLGVBQWVGLEdBQVc7UUFBRUcsVUFBQUEsaUVBQXVCLENBQUMsR0FBR0MsVUFBQUEsaUVBQVU7SUFDOUUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELFNBQVNDLElBQUs7UUFDaEMsSUFBSTtZQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFBTVAsS0FBSztnQkFDaEMsR0FBR0csT0FBTztnQkFDVkssU0FBUztvQkFDUCxjQUFjO29CQUNkLFVBQVU7b0JBQ1YsbUJBQW1CO29CQUNuQixtQkFBbUI7b0JBQ25CLGNBQWM7b0JBQ2QsNkJBQTZCO29CQUM3QixHQUFHTCxRQUFRSyxPQUFPO2dCQUNwQjtZQUNGO1lBRUEsSUFBSUYsU0FBU0csRUFBRSxFQUFFO2dCQUNmLE9BQU9IO1lBQ1Q7UUFDRixFQUFFLE9BQU9JLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLFdBQStCWixPQUFwQkssSUFBSSxHQUFFLGdCQUFrQixPQUFKTCxLQUFJLE1BQUlVO1lBQ3BELElBQUlMLE1BQU1ELFVBQVUsR0FBRyxNQUFNTTtZQUM3QixNQUFNLElBQUlHLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVMsT0FBUVQsQ0FBQUEsSUFBSTtRQUMvRDtJQUNGO0lBQ0EsTUFBTSxJQUFJVyxNQUFNO0FBQ2xCO0FBRUEsU0FBU0MsaUJBQWlCQyxJQUFZLEVBQUVDLE1BQWM7SUFDcEQsTUFBTUMsUUFBOEIsQ0FBQztJQUVyQyx1Q0FB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SUFBSSxDQUFDO1FBQzVDO0lBQ0Y7SUFFQSxzQ0FBc0M7SUFDdEMsTUFBTUMsZ0JBQXNDLENBQUM7SUFFN0MsTUFBTUMsY0FBYzNCLFNBQVM0QixNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUUzQyxJQUFJLEtBQUssU0FBUzJDLEVBQUUxQyxLQUFLLEtBQUs7SUFFekUsSUFBSXdDLFlBQVlaLE1BQU0sR0FBRyxHQUFHO1FBQzFCLE1BQU1lLFlBQVlILFlBQVlJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLSCxJQUFNRyxNQUFNSCxFQUFFekMsS0FBSyxFQUFFLEtBQUt1QyxZQUFZWixNQUFNO1FBQ3ZGVyxhQUFhLENBQUMsVUFBVSxHQUFHO1lBQ3pCeEMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLE9BQU8wQztZQUNQekMsVUFBVSxjQUFpQyxPQUFuQnNDLFlBQVlaLE1BQU0sRUFBQztZQUMzQ3pCLElBQUksSUFBSUMsT0FBT0MsV0FBVztRQUM1QjtJQUNGO0lBRUEsT0FBTztRQUNMZCxPQUFPZ0Q7UUFDUHJDLFVBQVU7UUFDVm1CLFNBQVM7SUFDWDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvcmF0ZXMvcHJvdmlkZXJzL2FsdGVybmF0aXZlVmVzLnRzP2ZkN2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF0ZSwgUmF0ZXNCdW5kbGUsIFByb3ZpZGVyUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMnXHJcblxyXG4vLyBBbHRlcm5hdGl2ZSBzb3VyY2VzIGZvciBWRVMgcmF0ZXMgdGhhdCBtaWdodCB3b3JrIGJldHRlclxyXG5jb25zdCBBTFRFUk5BVElWRV9WRVNfU09VUkNFUyA9IFtcclxuICB7XHJcbiAgICBuYW1lOiAnWEUuY29tJyxcclxuICAgIHVybDogJ2h0dHBzOi8vd3d3LnhlLmNvbS9jdXJyZW5jeWNvbnZlcnRlci9jb252ZXJ0Lz9BbW91bnQ9MSZGcm9tPVVTRCZUbz1WRVMnLFxyXG4gICAgcGFyc2VIdG1sOiB0cnVlXHJcbiAgfSxcclxuICB7XHJcbiAgICBuYW1lOiAnV2lzZS5jb20nLFxyXG4gICAgdXJsOiAnaHR0cHM6Ly93aXNlLmNvbS91cy9jdXJyZW5jeS1jb252ZXJ0ZXIvdXNkLXRvLXZlcy1yYXRlJyxcclxuICAgIHBhcnNlSHRtbDogdHJ1ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbmFtZTogJ0N1cnJlbmN5QVBJJyxcclxuICAgIHVybDogJ2h0dHBzOi8vYXBpLmN1cnJlbmN5YXBpLmNvbS92My9sYXRlc3Q/YmFzZV9jdXJyZW5jeT1VU0QmY3VycmVuY2llcz1WRVMnLFxyXG4gICAgcGFyc2VIdG1sOiBmYWxzZVxyXG4gIH1cclxuXVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoUmV0cnkodXJsOiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge30sIHJldHJpZXMgPSAyKTogUHJvbWlzZTxSZXNwb25zZT4ge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEyMC4wLjAuMCBTYWZhcmkvNTM3LjM2JyxcclxuICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2Uvd2VicCwqLyo7cT0wLjgnLFxyXG4gICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6ICdlbi1VUyxlbjtxPTAuNScsXHJcbiAgICAgICAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUsIGJyJyxcclxuICAgICAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxyXG4gICAgICAgICAgJ1VwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHMnOiAnMScsXHJcbiAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2VcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBBdHRlbXB0ICR7aSArIDF9IGZhaWxlZCBmb3IgJHt1cmx9OmAsIGVycm9yKVxyXG4gICAgICBpZiAoaSA9PT0gcmV0cmllcyAtIDEpIHRocm93IGVycm9yXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwICogKGkgKyAxKSkpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHRocm93IG5ldyBFcnJvcignQWxsIHJldHJ5IGF0dGVtcHRzIGZhaWxlZCcpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlVkVTRnJvbUhUTUwoaHRtbDogc3RyaW5nLCBzb3VyY2U6IHN0cmluZyk6IFBhcnRpYWw8UmF0ZXNCdW5kbGU+IHtcclxuICBjb25zdCByYXRlczogUGFydGlhbDxSYXRlc0J1bmRsZT4gPSB7fVxyXG4gIFxyXG4gIC8vIE11bHRpcGxlIHBhdHRlcm5zIHRvIHRyeSBmb3IgVVNEL1ZFU1xyXG4gIGNvbnN0IHVzZFBhdHRlcm5zID0gW1xyXG4gICAgLy8gWEUuY29tIHBhdHRlcm5zXHJcbiAgICAvMVxccypVU0RcXHMqPVxccyooW1xcZCxcXC5dKylcXHMqVkVTL2ksXHJcbiAgICAvVVNEXFxzKnRvXFxzKlZFU1tePl0qPihbXFxkLFxcLl0rKTwvaSxcclxuICAgIC8vIFdpc2UuY29tIHBhdHRlcm5zXHJcbiAgICAvMVxccypVU1xccypkb2xsYXJcXHMqPVxccyooW1xcZCxcXC5dKylcXHMqVkVTL2ksXHJcbiAgICAvVVNEXFxzKnRvXFxzKlZFU1tePl0qPihbXFxkLFxcLl0rKTwvaSxcclxuICAgIC8vIEdlbmVyaWMgcGF0dGVybnNcclxuICAgIC9VU0RcXHMqPVxccyooW1xcZCxcXC5dKylcXHMqVkVTL2ksXHJcbiAgICAvMVxccypVU0RcXHMqPVxccyooW1xcZCxcXC5dKylcXHMqQm9sw612YXIvaSxcclxuICAgIC9Ew7NsYXJcXHMqPVxccyooW1xcZCxcXC5dKylcXHMqQm9sw612YXIvaVxyXG4gIF1cclxuICBcclxuICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdXNkUGF0dGVybnMpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gaHRtbC5tYXRjaChwYXR0ZXJuKVxyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgIGNvbnN0IHJhdGUgPSBwYXJzZUZsb2F0KG1hdGNoWzFdLnJlcGxhY2UoLywvZywgJycpKVxyXG4gICAgICBpZiAoIWlzTmFOKHJhdGUpICYmIHJhdGUgPiA1MCAmJiByYXRlIDwgMTAwMCkgeyAvLyBTYW5pdHkgY2hlY2sgZm9yIHJlYXNvbmFibGUgcmFuZ2VcclxuICAgICAgICByYXRlc1snVVNELVZFUyddID0ge1xyXG4gICAgICAgICAgYmFzZTogJ1VTRCcsXHJcbiAgICAgICAgICBxdW90ZTogJ1ZFUycsXHJcbiAgICAgICAgICB2YWx1ZTogcmF0ZSxcclxuICAgICAgICAgIHByb3ZpZGVyOiBzb3VyY2UsXHJcbiAgICAgICAgICBhdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHJhdGVzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlVkVTRnJvbUpTT04oZGF0YTogYW55LCBzb3VyY2U6IHN0cmluZyk6IFBhcnRpYWw8UmF0ZXNCdW5kbGU+IHtcclxuICBjb25zdCByYXRlczogUGFydGlhbDxSYXRlc0J1bmRsZT4gPSB7fVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBsZXQgdXNkVmVzUmF0ZTogbnVtYmVyIHwgbnVsbCA9IG51bGxcclxuICAgIFxyXG4gICAgaWYgKHNvdXJjZSA9PT0gJ0N1cnJlbmN5QVBJJykge1xyXG4gICAgICBpZiAoZGF0YS5kYXRhPy5WRVM/LnZhbHVlKSB7XHJcbiAgICAgICAgdXNkVmVzUmF0ZSA9IGRhdGEuZGF0YS5WRVMudmFsdWVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodXNkVmVzUmF0ZSAmJiB1c2RWZXNSYXRlID4gNTAgJiYgdXNkVmVzUmF0ZSA8IDEwMDApIHtcclxuICAgICAgcmF0ZXNbJ1VTRC1WRVMnXSA9IHtcclxuICAgICAgICBiYXNlOiAnVVNEJyxcclxuICAgICAgICBxdW90ZTogJ1ZFUycsXHJcbiAgICAgICAgdmFsdWU6IHVzZFZlc1JhdGUsXHJcbiAgICAgICAgcHJvdmlkZXI6IHNvdXJjZSxcclxuICAgICAgICBhdDogZGF0YS5tZXRhPy5sYXN0X3VwZGF0ZWRfYXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcGFyc2UgJHtzb3VyY2V9IEpTT04gcmVzcG9uc2U6YCwgZXJyb3IpXHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiByYXRlc1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWx0ZXJuYXRpdmVWRVNSYXRlcygpOiBQcm9taXNlPFByb3ZpZGVyUmVzdWx0PiB7XHJcbiAgY29uc3QgYWxsUmF0ZXM6IFJhdGVbXSA9IFtdXHJcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdXHJcbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuUFVCTElDX0ZYX0FQSV9LRVlcclxuICBcclxuICAvLyBUcnkgbXVsdGlwbGUgc291cmNlcyBpbiBwYXJhbGxlbFxyXG4gIGNvbnN0IHNvdXJjZVByb21pc2VzID0gQUxURVJOQVRJVkVfVkVTX1NPVVJDRVMubWFwKGFzeW5jIChzb3VyY2UpID0+IHtcclxuICAgIC8vIFNraXAgc291cmNlcyB0aGF0IHJlcXVpcmUgQVBJIGtleSBpZiB3ZSBkb24ndCBoYXZlIG9uZVxyXG4gICAgaWYgKHNvdXJjZS5uYW1lID09PSAnQ3VycmVuY3lBUEknICYmICFhcGlLZXkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzb3VyY2U6IHNvdXJjZS5uYW1lLFxyXG4gICAgICAgIHJhdGVzOiBbXSxcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogJ0FQSSBrZXkgcmVxdWlyZWQgYnV0IG5vdCBwcm92aWRlZCdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBsZXQgdXJsID0gc291cmNlLnVybFxyXG4gICAgICBcclxuICAgICAgLy8gQWRkIEFQSSBrZXkgdG8gVVJMIGlmIHJlcXVpcmVkXHJcbiAgICAgIGlmIChzb3VyY2UubmFtZSA9PT0gJ0N1cnJlbmN5QVBJJyAmJiBhcGlLZXkpIHtcclxuICAgICAgICB1cmwgPSBgJHtzb3VyY2UudXJsfSZhcGlrZXk9JHthcGlLZXl9YFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KHVybCwge1xyXG4gICAgICAgIG5leHQ6IHsgcmV2YWxpZGF0ZTogMzYwMCB9XHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoc291cmNlLnBhcnNlSHRtbCkge1xyXG4gICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcclxuICAgICAgICBjb25zdCByYXRlcyA9IHBhcnNlVkVTRnJvbUhUTUwoaHRtbCwgc291cmNlLm5hbWUpXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNvdXJjZTogc291cmNlLm5hbWUsXHJcbiAgICAgICAgICByYXRlczogT2JqZWN0LnZhbHVlcyhyYXRlcyksXHJcbiAgICAgICAgICBzdWNjZXNzOiBPYmplY3Qua2V5cyhyYXRlcykubGVuZ3RoID4gMFxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgY29uc3QgcmF0ZXMgPSBwYXJzZVZFU0Zyb21KU09OKGRhdGEsIHNvdXJjZS5uYW1lKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZS5uYW1lLFxyXG4gICAgICAgICAgcmF0ZXM6IE9iamVjdC52YWx1ZXMocmF0ZXMpLFxyXG4gICAgICAgICAgc3VjY2VzczogT2JqZWN0LmtleXMocmF0ZXMpLmxlbmd0aCA+IDBcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgJHtzb3VyY2UubmFtZX0gZmFpbGVkOmAsIGVycm9yKVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNvdXJjZTogc291cmNlLm5hbWUsXHJcbiAgICAgICAgcmF0ZXM6IFtdLFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSlcclxuICBcclxuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHNvdXJjZVByb21pc2VzKVxyXG4gIFxyXG4gIC8vIENvbGxlY3QgYWxsIHN1Y2Nlc3NmdWwgcmF0ZXNcclxuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xyXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnICYmIHJlc3VsdC52YWx1ZS5zdWNjZXNzKSB7XHJcbiAgICAgIGFsbFJhdGVzLnB1c2goLi4ucmVzdWx0LnZhbHVlLnJhdGVzKVxyXG4gICAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XHJcbiAgICAgIGVycm9ycy5wdXNoKHJlc3VsdC5yZWFzb24/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InKVxyXG4gICAgfVxyXG4gIH0pXHJcbiAgXHJcbiAgaWYgKGFsbFJhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmF0ZXM6IHt9LFxyXG4gICAgICBwcm92aWRlcjogJ0FsdGVybmF0aXZlLVZFUycsXHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogYEFsbCBzb3VyY2VzIGZhaWxlZDogJHtlcnJvcnMuam9pbignLCAnKX1gXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEF2ZXJhZ2UgcmF0ZXMgZnJvbSBtdWx0aXBsZSBzb3VyY2VzXHJcbiAgY29uc3QgYXZlcmFnZWRSYXRlczogUGFydGlhbDxSYXRlc0J1bmRsZT4gPSB7fVxyXG4gIFxyXG4gIGNvbnN0IHVzZFZlc1JhdGVzID0gYWxsUmF0ZXMuZmlsdGVyKHIgPT4gci5iYXNlID09PSAnVVNEJyAmJiByLnF1b3RlID09PSAnVkVTJylcclxuICBcclxuICBpZiAodXNkVmVzUmF0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgYXZnVXNkVmVzID0gdXNkVmVzUmF0ZXMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIudmFsdWUsIDApIC8gdXNkVmVzUmF0ZXMubGVuZ3RoXHJcbiAgICBhdmVyYWdlZFJhdGVzWydVU0QtVkVTJ10gPSB7XHJcbiAgICAgIGJhc2U6ICdVU0QnLFxyXG4gICAgICBxdW90ZTogJ1ZFUycsXHJcbiAgICAgIHZhbHVlOiBhdmdVc2RWZXMsXHJcbiAgICAgIHByb3ZpZGVyOiBgQXZlcmFnZSBvZiAke3VzZFZlc1JhdGVzLmxlbmd0aH0gc291cmNlc2AsXHJcbiAgICAgIGF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIHJhdGVzOiBhdmVyYWdlZFJhdGVzLFxyXG4gICAgcHJvdmlkZXI6ICdBbHRlcm5hdGl2ZS1WRVMnLFxyXG4gICAgc3VjY2VzczogdHJ1ZVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiQUxURVJOQVRJVkVfVkVTX1NPVVJDRVMiLCJuYW1lIiwidXJsIiwicGFyc2VIdG1sIiwiZmV0Y2hXaXRoUmV0cnkiLCJvcHRpb25zIiwicmV0cmllcyIsImkiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsIm9rIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkVycm9yIiwicGFyc2VWRVNGcm9tSFRNTCIsImh0bWwiLCJzb3VyY2UiLCJyYXRlcyIsInVzZFBhdHRlcm5zIiwicGF0dGVybiIsIm1hdGNoIiwicmF0ZSIsInBhcnNlRmxvYXQiLCJyZXBsYWNlIiwiaXNOYU4iLCJiYXNlIiwicXVvdGUiLCJ2YWx1ZSIsInByb3ZpZGVyIiwiYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJwYXJzZVZFU0Zyb21KU09OIiwiZGF0YSIsInVzZFZlc1JhdGUiLCJWRVMiLCJtZXRhIiwibGFzdF91cGRhdGVkX2F0IiwiZ2V0QWx0ZXJuYXRpdmVWRVNSYXRlcyIsImFsbFJhdGVzIiwiZXJyb3JzIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIlBVQkxJQ19GWF9BUElfS0VZIiwic291cmNlUHJvbWlzZXMiLCJtYXAiLCJzdWNjZXNzIiwibmV4dCIsInJldmFsaWRhdGUiLCJ0ZXh0IiwiT2JqZWN0IiwidmFsdWVzIiwia2V5cyIsImxlbmd0aCIsImpzb24iLCJtZXNzYWdlIiwicmVzdWx0cyIsImFsbFNldHRsZWQiLCJmb3JFYWNoIiwicmVzdWx0Iiwic3RhdHVzIiwicHVzaCIsInJlYXNvbiIsImpvaW4iLCJhdmVyYWdlZFJhdGVzIiwidXNkVmVzUmF0ZXMiLCJmaWx0ZXIiLCJyIiwiYXZnVXNkVmVzIiwicmVkdWNlIiwic3VtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/rates/providers/alternativeVes.ts\n"));

/***/ })

});